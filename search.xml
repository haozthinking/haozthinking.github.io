<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[SVM]]></title>
      <url>%2F2017%2F04%2F16%2FSVM%2F</url>
      <content type="text"><![CDATA[介绍支持向量机是一种很好的机器学习方法，在面试中多次被用到。 其基本问题为在训练集D在样本空间找到一个超平面，使得这个超平面起到最好的分类效果。可是何谓最好呢？在支持向量机里面最好的定义就是“最小的取最大”这里的最小即为两种分类到分界面的距离最小，而最优的份界面的选择就是要使得这里的到分界面距离最小的值取取最大的支持向量。而到中间距离最小的点即为支持向量。 支持向量机有三类，分别是线性支持向量机，线性可分支持向量机和非线性支持向量机。 线性可分支持向量机基本思想线性可分支持向量机我们重点介绍，他是线性支持向量机和非线性支持向量机的基础。在样本空间中，划分超平面的方程的表示形式如下所示： ​ $$(1)w^Tx + b = 0 $$ 其中$w^T$ = ($w_1;w_2;w_3;….;w_d$)为法向量决定了该划分超平面的距离，而b为原点距决定了超平面与原点间的距离。由此可知，划分超平面可以由法向量 $w$ 和原点距位移 $b$所确定，所确定的超平面计为$(w,b)$,则样本空间内的一点$x$到$(w,b)$的距离可以写为 ​ $$(2)r=\frac{|w^Tx + b|}{||w||}$$ 如果有一点可以被正确分类，那么不难知道如果他的x满足$ w^Tx_i + b &gt; 0 $时$ y_i = +1 $,$ w^Tx_i + b &lt; 0 $时$ y_i = -1 $ 而如果我们在这里把0的标准换位1和－1的标准，令以下成立：$$(3)w^Tx_i + b =&gt; 1 ; y_i = +1 ; w^Tx_i + b &lt;= -1 ; y_i = -1$$在使这里的大于等于和小于等于号为等号时满足的条件为支持向量。 线性可分支持向量机这里使用的是硬间隔，即在间隔中不允许存在分类点，而线性支持向量机使用的是软间隔这也是线性可分支持向量机和线性支持向量机的区别所在。 由上面知道，如果当等号成立时取支持向量。那么当他取支持向量的时候其距离为 $ y=\frac{2}{||w||}$。而我们寻找的就是使下列条件成立时的$w$和$b$的值，该数值可以使得$y$为最大。那么其约束条件为下式：$$(4)\max_{w,b}\frac{2}{||w||}$$$$(5)s.t.y_i(w^Tx_i+b) \geq 1, i =1,2,3……m.$$ 而若要求$\frac{1}{||w||}$的最大值，那么就是要求$||w||$的最小值。则就可以将上述的$(4)$式改写为以下形式：$$(6)\min_{w,b}\frac{1}{2}||w||^2\$$则5，6式即为支持向量机的基本型，其也为线性可分向量机的基本形态。 公式求解对于以上$(5)(6)$两式，在这里可以使用拉格朗日乘子法对其进行求解，对于$(5)$式的每条约束，我们都可以添加拉格朗日乘子$\alpha_i \geq 0$,那么该问题的拉格朗日函数就可以写成以下式子： $$(7)L(w,b,\alpha) = \frac{1}{2}||w||^2 + \sum_{i=1}^m\alpha_i(1-y_i(w^Tx_i+b))$$ 接下来用拉格朗日乘子法的套路，使用$L(w,b,\alpha)$对其进行求偏导的过程，即可消去$w$和$b$，可得他的对偶问题$(10)$：$$(8)w = \sum_{i=1}^m\alpha_iy_ix_i$$ $$(9)0 = \sum_{j=1}^m\alpha_iy_i ;$$ $$(10)max\alpha \sum{i=1}^m\alphai - \frac{1}{2}\sum{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j$$对$\alpha$求解后，即可求出$w$和$b$的模型： $$(12)f(x) = w^Tx + b = \sum_{i=1}^m\alpha_iy_ix_i^Tx_i＋b$$ 由以上约束可知，其满足KKT条件即： $$(13)\alpha_i \geq 0 ; y_if(x_i)-1\geq0; \alpha_i(y_if(x_i)-1)=0$$ 于是对于所有的点可知，要么满足$\alpha_i$=0或者$y_if(x_i)=1$对于支持向量的点即为$y_if(x_i)=1$，对于其他点就为$\alpha_i$=0。而训练所需的为支持向量点，其余点就可忽略，最终模型仅仅和支持向量有关系。 求解方法——SMO算法确定$\alpha$方法SMO方法的思想在于，除了两个变量$\alpha_i$和$\alpha_j$其余变量全部固定，然后重复下列两部获得更新后的$\alpha_i$和$\alpha_j$: 选取两个需要更新的$\alpha_i$和$\alpha_j$； 固定$\alpha_i$和$\alpha_j$外的其他参数，求解更新后的$\alpha_i$和$\alpha_j$； 只要选取的$\alpha_i$和$\alpha_j$有一个不满足KKT条件，那么目标函数就会在迭代后变得更小。一般SMO选取为两个差别很大的变量，对他们进行变化会得到更好的效果。 对于SMO的方法，由$L(w,b,\alpha)$对$b$求偏导可知$(9)$所以不难得出下式: $$(14)\alpha_iy_i+\alpha_jyj+c = 0 ; c=\sum{k=0,k!=i,j}^m\alpha_ky_k$$ 其中$\alpha_i$和$\alpha_j$可以相互表示，那么假设用$\alpha_i$将$\alpha_j$表示后，带入(10) 后仅有一个参数，因此就很好计算$\alpha_i$ 求解$b$的方法对于所有的支持向量都有$,y_sf(x_s)=1$即： $$(15)ys(\sum{i}\alpha_iy_ix_i^Tx_s+b)=1$$ 通过此式子就可以求出b，原则上可以使用任意一个式子来求b，但一般使用的为多个求平均值的方法来做: $$(16)b=\frac{1}{|S|}\sum_{s\epsilon S}(ys-\sum{i\epsilon S}\alpha_iy_ix_i^Tx_i)$$ 线性支持向量机基本思想线性可分支持向量机很容易对两个区别明显且没有样本相交的情况下才能实现，现实生活中这种很理想的情况并不存在。在这些情况下线性可分支持向量机就失效了；即使可以通过线性可分支持向量机对其进行很好的分类，但是他所训练出的模型也很容易产生过拟合，于是这里就要使用线性支持向量机。 上面说过，线性支持向量机和线性可分支持向量机最大的区别在于线性可分支持向量机所用的为硬间隔,线性支持向量机采用的是软间隔。软间隔的表示如下图所示： 软间隔和硬间隔最最大的区别在于对于软间隔来说，并不需要所有的样本都能划分正确。不一定满足约束条件: $$y_i(w^Tx_i+b)\geq 1$$ 而在能满足的情况下，当然需要不满足的样本尽可能的少。所以对于线性可分支持向量机来说，优化目标为： $$(17)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^ml_{0/1}(y_i(w^Tx_i+b)-1)$$ 其中$C&gt; 0$为一个常数，而$l_{0/1}(z)$为“0/1损失函数”,当$z&lt;0$时为1，其余时候为0。 由上面的式子可知，如果$C$的值过于大，那么他在每次犯错后所要付出的代价就会很大，而C很小时其每次所需的代价就比较小。于是我们极端来看不难得出当C为无限小为0时，他随便犯错都无所谓，这时候线性支持向量机的作用就失去了。而当$C$为无限大的时候，这时候犯一点错误就会受到很大的惩罚，这时候一点错误都不敢犯。因此当$C$为无限大时，线性支持向量机就变为了线性可分支持向量机。不难看出，线性可分支持向量机是线性支持向量机在$C$为无穷大时的一种特例。 但是在实际的应用场景中，$l{0/1}(z)$损失的数学性质不好，非凸函数且非连续函数。因此$(17)$式不好求解，这时候在支持向量机中荷叶损失函数(hinge损失)：$$(18)l{hinge}(z)=\max(0,1-z);$$当把$l{0/1}(z)$损失函数变成了$l{hinge}(z)$损失函数后，则$(17)$式变为下式$(19)$在引入松弛因子后，就成了$(20)$式：$$(19)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\max(0,1-y_i(w^Tx_i))$$ $$(20.1)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\xi_i$$ $$(20.2)s.t. y_i(w^Tx_i+b)\geq 1-\xi_i;\xi_i\geq0,i=1,2,3…m.$$ 如上图所示，上图分别为hinge函数损失函数，指数损失函数和对率损失函数。这三种损失函数的发展趋势都是一样的，但是在支持向量机中中，由于只要是等于1就算支持向量，原则上在其等于1时不能有损失，而指数损失函数和对率损失函数在等于1甚至是大于1时都有损失。因此在线性支持向量机中使用最多的是hinge损失函数，在有的教材中hinge损失函数也叫做SVM损失函数。 公式求解除了线性可分支持向量机用的是硬间隔，线性支持向量机用的是软间隔外，在其余方面这两个线性支持向量机差别不大，因此对于其公式求解，也使用如同线性可分支持向量机的求解方法，即用拉格朗日乘子法。类比公式$(7)$不难得出线性支持向量机的拉格朗日函数：$$L(w,b,\alpha,\xi,\mu)=\frac{1}{2}||w||^2+C\sum_{i=1}^m\xii+\sum{i=1}^m\alpha_i(1-\xi_i-y_i(w^Txi+b))-\sum{i=1}^m\mu_i\xi_i$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux学习之：定制shell提示符]]></title>
      <url>%2F2017%2F04%2F16%2FLinux%E5%AD%A6%E4%B9%A0%E4%B9%8B%EF%BC%9A%E5%AE%9A%E5%88%B6shell%E6%8F%90%E7%A4%BA%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[在系统初始化提示符的时候，提示符的样子如下: haoz@linux:~$ 通过以下命令可以查到PS1的值 修改命令提示行的样式1echo $PS1 再通过下图所示的shell提示符中使用的转义字符即可对shell提示符进行自己想要的修改命令: 修改命令提示行的颜色除了自定义命令行的显示类型外，还可以定义命令行的现实颜色，具体代码如下： 1PS1=&quot;\[\033[0;41m\]&lt;[\w]\u@\h$:&gt;\[\033[0m\]&quot; 此命令可以将命令行的背景换为红色 更改41m可以将其换位其他颜色。 修改命令提示行的光标位置1PS1=&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;[\w]\u@\h$:&gt;&quot; 此命令行的作用在每输入一行时，屏幕上方会出现一个红色的横条，横条中用黄色显示文本的时间。 下方命令对应光标移动转移序列的对应关系： 保存命令行要想把修改好的命令行永久的保存起来，就得把他存在某个地方，这里就是要存在.bashrc文件中。即将下列命令行添加到文件中： 12PS1=&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;[\w]\u@\h$:&gt;&quot;export PS1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux学习之：vi使用简介]]></title>
      <url>%2F2017%2F04%2F15%2FLinux%E5%AD%A6%E4%B9%A0%E4%B9%8B%EF%BC%9Avi%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[12# 进入vi界面$ vi vi命令模式点击esc即可进入vi的命令模式 在这里可以进行一系列命令对vi进行操作 比如说保存，关闭，查找等命令 :w 保存命令 L或者右箭头：右移动 H或者左箭头：左移动 J或者下箭头：下移动 K或者上箭头：上移动 数字0:至本行开头 Ctrl-F或者page down：下翻一页 Ctrl-B或者page up：上翻一页 shift+g：至文件的最后一行 number＋g：至文件的第number行 /:对文本进行搜索 {[%],[1,\$][1,5]}s/A/B/g(其中前面表示从多少行到多少行，%表示从第一到最后，[1,$]表示从1到最后,[1,5]表示从1到5行；s表示命令为替换操作，即搜索和替换；A表示要被替换成的语句；B为要替换的语句；g即为全局搜索) 使用n切换到下一个文件，使用N切换到上一个文件 使用buffers展示文件 r：读入文件 vi编辑模式1.进入插入模式 点击i即进入插入模式 点击o在上方插入 点击O在下方插入 点击x删除当前字符 点击“number”+x删除当前字符和之后number－1个字符 点击dd剪切当前行 点击yy复制当前行 点击p粘贴 点击“number”+dd删除当前行和后面的number－1行 点击J命令移动合并行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之抽象工厂模式]]></title>
      <url>%2F2017%2F01%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[抽象工厂模式抽象工厂模式概念简单工厂模式和工厂方法模式的本质是给入不同的属性，通过不同的属性调用不同的类从而得到不同的对象。而抽象工厂模式可以将一组具有同样主题的工厂封装起来，在简单工厂模式前加一层抽象的概念。即抽象工厂模式是一个父类工厂，通过该抽象工厂模式产生具体工厂。抽象工厂模式即为工厂的工厂。 抽象工厂模式有四种角色： 抽象工厂：担任这个角色的是工厂方法模式的核心，它是与应用系统商业逻辑无关的。 具体工厂：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统的商业逻辑紧密相关的。 抽象产品：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。 具体产品：这个角色用以代表具体的产品。 抽象工厂模式类图这里我们定义一个抽象工厂为”University”。通过这个抽象工厂生成两个具体工厂为”BUPT”和”BNU”。其中BUPT 中男生偏多且毕业生大都为工程师，所以从BUPT中生产的产品为”Boy”和”Engineer”。而BNU中女生偏多且很多毕业生做教师，于是从BNU这个工厂生产的产品为”Girl”和”Teacher”. 抽象工厂模式代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface University&#123; public Sex getSex(); public Job getJob();&#125;public interface Sex&#123; public String getSexName(); &#125;public interface Job&#123; public String getJobName(); &#125;public class BUPT implements University&#123; public Sex getSex()&#123; return new Boy(); &#125; public Job getJob()&#123; return new Engineer(); &#125;&#125;public class Engineer implements Job&#123; public String getJobName()&#123; return "engineer"; &#125;&#125;public class Boy implements Sex&#123; public String getSexName()&#123; return "boy"; &#125;&#125;public class Student&#123; public void graduate(University s)&#123; System.out.println("A graduate student is a "+s.getSex().getSexName()+" and he/she get a job of "+s.getJob().getJobName(); &#125; public static void main(String[] args)&#123; Student s = new Student(); University u = new BUPT(); s.graduate(u); &#125;&#125; 产品等级结构和产品族产品等级结构产品等级结构即产品的继承结构。比如一个抽象类为球类运动，其子类有足球、篮球等；则球类运动和篮球、足球就构成了一个产品等级结构。其中抽象的球类运动为父类，具体的球类运动为子类。 产品族在抽象工厂模式中，产品族是由同一个工厂产生，但位于不同产品等级结构中的一组产品。比如说上面的例子，产品Boy和产品Engineer都是BUPT这个工厂生产出来的。但是Boy这个产品是和Sex这个抽象父类构成一个产品等级结构，Engineer这个产品是和Job这个抽象父类构成一个产品等级结构。Boy和Engineer组成了一个产品族。 由产品族和产品等级结构就可以唯一的确定一个产品。 抽象工厂模式和工厂方法模式的区别介绍完了产品等级结构和产品族后，抽象工厂模式和工厂方法模式的区别就很明显了。工厂方法模式针对的是一个产品等级，而抽象工厂模式是针对多个产品等级。当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>%2F2017%2F01%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[设计模式之工厂模式工厂模式在面向对象的设计中，其是一个用于创建其他对象的对象。其根据不同的参数来创建不同的对象并实现不同的分配方案。例如创建“人”这个对象，输入男女的特征，工厂模式就为我们创建男人/女人。(上帝即视感！) 工厂模式分为三类： 简单工厂模式 工厂模式方法 抽象工厂模式 此篇先介绍简单工厂模式和工厂模式方法 工厂模式类图：这里我们就使用工厂模式来造人，我们先造一个男人，他每天的工作是吃饭睡觉打豆豆，顺便再踢踢球。而我们再造一个女人，那么她每天的工作也是吃饭睡觉打豆豆，顺便再买买买！下面就是该UML的类图： 简单工厂模式示例代码简单工厂模式代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//抽象产品——人类 有eat,sleep,beat方法abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat();&#125;//具体产品--男人 有eat,sleep,beat,soccer方法class Male extends Human&#123; public void eat()&#123; System.out.println("Man can eat."); &#125; public void sleep()&#123; System.out.println("Man can sleep."); &#125; public void beat()&#123; System.out.println("Man can beat doudou."); &#125;&#125;//具体产品--女人 有eat,sleep,beat,buy方法class Female extends Human&#123; public void eat()&#123; System.out.prinln("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125;&#125;/*简单工厂模式，当性别为male时构建男生方法当性别为female时构建女生方法*/public class HumanFactory&#123; public static Human createHuman(String gender)&#123; Human human = null; if(gender.equals("male")&#123; human = new Man(); &#125;else if(gender.equals("female"))&#123; human = new Female(); &#125; return human; &#125; &#125;/*女娲造人方法，用该方法造一个男人，再造一个女人*/public class Goddess&#123; pubic static void main(String[] args) throws IOException&#123; Human man = HumanFactory.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); Human woman = HumanFactory.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125;&#125; 工厂方法模式示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//抽象产品--人类abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat(); &#125;//具体产品--男人，他有吃饭，睡觉，打豆豆以及看足球的方法class Male extends Human&#123; public void eat()&#123; System.out.println("Male can eat."); &#125; public void sleep()&#123; System.out.println("Male can sleep."); &#125; public void beat()&#123; System.out.println("Male can beat doudou."); &#125; public void soccer()&#123; System.out.println("Male can play soccer."); &#125;&#125;//具体产品--女人，她有吃饭，睡觉，打豆豆及买买买的需求class Female extends Human&#123; public void eat()&#123; System.out.println("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125; public void buy()&#123; System.out.println("Female can buy"); &#125;&#125;//从这里开始使用工厂方法模式//定义一个抽象工厂类Humanabstract class HumanFactory&#123; public abstract Human createHuman(String gender) throws IOException&#123; return new Human(); &#125;&#125;//定义一个具体工厂类Female,来生产女人class FemaleFactory extends HumanFactory&#123; public Human createHuman(String gender) throws IOException&#123; return new Female(); &#125;&#125;//定义一个具体工厂类Male,来生产男人class MaleFactory extends HumanFactory&#123; public Male createHuman(String gender) throws IOException&#123; return new Male(); &#125;&#125;//定义一个上帝主类，开始造人public class Goddess&#123; public static void main(String[] args) throws IOException&#123; //创造男人 HumanFactory hfm = new MaleFactory(); Human man = hfm.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); //创造女人 HumanFactory hff = new FemaleFactory(); Human woman = hff.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125; 工厂模式用处工厂模式虽然思想简单，但是在java中有很多的用处。比如说在Java库中，根据输入不同的参数类型对象，getInstance()方法就会返回不同的结果。这里就使用了工厂模式的知识。 123456java.util.Calendar-getInstance()java.util.Canlendar-getInstance(TimeZone zone)java.util.Canlendar-getInstance(Locate aLocale)java.util.Canlendar-getInstance(TimeZone zone,Locate aLocale)java.text.NumberFormat-getInstance()java.text.NumberFormat-getInstance(Locate inLocate)]]></content>
    </entry>

    
  
  
</search>
