<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[LeetCode 13. (E)Roman to Integer]]></title>
      <url>%2F2017%2F05%2F07%2FLeetCode-13-E-Roman-to-Integer%2F</url>
      <content type="text"><![CDATA[题目描述Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 算法描述本题目是要给出一个罗马数字，然后将该罗马数字变成整数的过程。由罗马数字的组成规则可以得知，阿拉伯数字｛1，5，10，50，100，500，1000｝分别对应于罗马数字的{‘I’,’V’,’X’,’L’,’C’,’D’,’M’}。 并且观察到罗马数字和阿拉伯数字转换的小规律为: IIV = 5 - 1 - 1 = (-1) + (-1) + 5 = 3 VII = 5 + 1 + 1 = 7 I在V前面并且I比V小，因此I被解释为负数。 I在V后面并且I比V小，因此I被解释为正数。 因此算法可以这样设计，一次把所有字符串扫描一遍，从第一个字符开始到最后一个字符。一次比较当前字符a和下一个字符b,如果a\b那么就解释为a+b。 代码实现1234567891011121314151617181920212223class Solution &#123;public: int romanToInt(std::string s)&#123; int sum = 0; char char_arr[] = &#123;'I','V','X','L','C','D','M'&#125;; int int_arr[] = &#123;1,5,10,50,100,500,1000&#125;; std::map&lt;char,int&gt; roman_map; int man_len = sizeof(char_arr) / sizeof(char); for(int i = 0 ; i &lt; man_len ;i++)&#123; roman_map.insert(std::pair&lt;char,int&gt;(char_arr[i],int_arr[i])); &#125; for(int i = 0; i &lt; s.length() - 1;i++)&#123; if (roman_map[s[i]] &gt;= roman_map[s[i + 1]])&#123; sum += roman_map[s[i]]; &#125; if (roman_map[s[i]] &lt; roman_map[s[i+1]])&#123; sum -= roman_map[s[i]]; &#125; &#125; sum += roman_map[s[s.length() - 1]]; return sum; &#125;&#125;; 补充STL容器之map:map是C++的STL提供的一个很常用的键值对容器。在一一对应的数据结构中map很常用。下面对map的基本操作进行说明。 1.头文件include 2.定义map my_Map; 3.插入数据1.my_Map[“a”] = 1; 2.my_Map.insert(map\::value_type(“b”,2)); 3.my_Map.insert(pair\)(“c”,3)); 4.my_Map.insert(make_pair\)(“d”,4); 4.查找数据int i = my_Map[“a”]; 5.删除数据my_Map.erase(my_Itr); 6.返回元素数目]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[支持向量机-非线性支持向量机]]></title>
      <url>%2F2017%2F05%2F06%2F%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[非线性支持向量机而现实生活远比理想复杂，样本空间很难是一个能被线性分割的超平面，对于很多情况来说仅仅依靠线性是不行的。而我们定义，如果不能靠线性平面分开，而可以通过一个超曲面将正负例正确分开的问题为非线性可分问题。 核技巧非线性不好求解，希望通过线性分类问题来解决该类问题。我们所采用的方法即为对原非线性问题进行一个线性变换。通过求解该线性问题即可得出原非线性问题。如下方图所示，即将一个在二维平面的非线性问题变为了一个在三维平面的线性问题，如下图所示。 因此，我们可以知道，用线性分类方法求解非线性分类方法分为两步，首先第一步是使用一个变换讲原数据映射到一个新的空间，从而将在原空间内的非线性问题转换成为一个在新空间内的线性问题。第二步即对新空间内的线性问题用线性分类学习的方法从训练数据中学习分类模型。其中核技巧就属于这种问题。 核函数 令$\phi(x)$表示将x高位映射后的向量，于是在特征空间中划分平面可以将模型可以分为:$$(1)f(x)=w^T\phi(x)+b$$其中$w$和$b$是两个模型参数有： $$(2)\min_{w,b}\frac{1}{2}||w||^2,s.t.y_i(w^T\phi(x_i)+b)\ge1$$ 其对偶问题为: $$(3)\max_\alpha\sum_{i=1}^m\alpha_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j,s.t.\sum_{i=1}^m\alpha_iy_i=0, 0\le\alpha_i\le C$$ 不难看出，非线性支持向量机和线性支持向量机的区别在于求解x的维度不同，对于线性支持向量机为$x_i$而非线性支持向量机为x高维映射后的向量为$\phi(x_i)$. 这里的困难是计算$\phi(x_i)^T\phi(x_i)$是相当困难的。所以在此引入一个函数,该函数即为核函数$$(4)\kappa(x_i,x_j)=&lt;\phi(x_i),\phi(x_j)&gt;=\phi(x_i)^T\phi(x_j)$$对(3)进行求解后可以得到:$$(5)f(x)=w^T\phi(x)+b=\sum_{i=1}^m\alpha_iy_i\phi(x_i)^T\phi(x_j)+b=\sum_{i=1}^m\alpha_iy_i\kappa(x_i,x_j)+b$$ 常用核函数核函数的选择时非线性支持向量机中的一个很重要的问题，他和核函数最终的性能有很大的关系。下面显示了几种常用的核函数: 名称 表达式 线性核 $\kappa(x_i,x_j)=x_i^Tx_j$ 多项式核 $\kappa(x_i,x_j)=(x_jx_i + 1)^q $ 高斯核 $\kappa(x_i,x_j)=\exp(-\frac{ w_i-w_j ^2}{2\sigma^2})$ 拉普拉斯核 $\kappa(x_i,x_j)=exp(-\frac{\ \ w_i-w_j\ \ }{\sigma})$ Sigmoid核 $\kappa(x_i,x_j)=tanh(\beta x_i^Tx_j+\theta)$ 非线性支持向量机将线性支持向量机扩展到非线性支持向量机，只需要将线性支持向量机中的对偶形式的内积换为核函数即可。$$f(x)= sign(\sum_{i=1}^N\alpha_i^*y_iK(x_i,x_j) + b$$上式为非线性支持向量机的分类决策函数$K(x,z)$为其正定核函数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[支持向量机-线性支持向量机]]></title>
      <url>%2F2017%2F05%2F06%2F%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[线性支持向量机基本思想线性可分支持向量机很容易对两个区别明显且没有样本相交的情况下才能实现，现实生活中这种很理想的情况并不存在。在这些情况下线性可分支持向量机就失效了；即使可以通过线性可分支持向量机对其进行很好的分类，但是他所训练出的模型也很容易产生过拟合，于是这里就要使用线性支持向量机。 上面说过，线性支持向量机和线性可分支持向量机最大的区别在于线性可分支持向量机所用的为硬间隔,线性支持向量机采用的是软间隔。软间隔的表示如下图所示： 软间隔和硬间隔最最大的区别在于对于软间隔来说，并不需要所有的样本都能划分正确。不一定满足约束条件:$$y_i(w^Txi+b)\geq 1$$而在能满足的情况下，当然需要不满足的样本尽可能的少。所以对于线性可分支持向量机来说，优化目标为：$$(17)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^ml{0/1}(y_i(w^Txi+b)-1)$$其中$C&gt; 0$为一个常数，而$l{0/1}(z)$为“0/1损失函数”,当$z&lt;0$时为1，其余时候为0。 由上面的式子可知，如果$C$的值过于大，那么他在每次犯错后所要付出的代价就会很大，而C很小时其每次所需的代价就比较小。于是我们极端来看不难得出当C为无限小为0时，他随便犯错都无所谓，这时候线性支持向量机的作用就失去了。而当$C$为无限大的时候，这时候犯一点错误就会受到很大的惩罚，这时候一点错误都不敢犯。因此当$C$为无限大时，线性支持向量机就变为了线性可分支持向量机。不难看出，线性可分支持向量机是线性支持向量机在$C$为无穷大时的一种特例。 hinge损失函数但是在实际的应用场景中，$l{0/1}(z)$损失的数学性质不好，非凸函数且非连续函数。因此$(17)$式不好求解，这时候在支持向量机中荷叶损失函数(hinge损失)：$$(18)l{hinge}(z)=\max(0,1-z);$$当把$l{0/1}(z)$损失函数变成了$l{hinge}(z)$损失函数后，则$(17)$式变为下式$(19)$在引入松弛因子后，就成了$(20)$式：$$(19)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\max(0,1-y_i(w^Tx_i))$$ $$(20.1)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\xi_i$$ $$(20.2)s.t. y_i(w^Tx_i+b)\geq 1-\xi_i;\xi_i\geq0,i=1,2,3…m.$$ 如上图所示，上图分别为hinge函数损失函数，指数损失函数和对率损失函数。这三种损失函数的发展趋势都是一样的，但是在支持向量机中中，由于只要是等于1就算支持向量，原则上在其等于1时不能有损失，而指数损失函数和对率损失函数在等于1甚至是大于1时都有损失。因此在线性支持向量机中使用最多的是hinge损失函数，在有的教材中hinge损失函数也叫做SVM损失函数。 而将hinge损失函数融入到支持向量机中，那么支持向量机就有了另外一种解释，就是最小化以下的目标函数:$$\sum^N_{i=1}[1-y_i(wi+b)]+\lambda||w||^2$$其中第一项$1-y_i(wi+b)+$就为hinge损失函数 公式求解除了线性可分支持向量机用的是硬间隔，线性支持向量机用的是软间隔外，在其余方面这两个线性支持向量机差别不大，因此对于其公式求解，也使用如同线性可分支持向量机的求解方法，即用拉格朗日乘子法。类比公式$(7)$不难得出线性支持向量机的拉格朗日函数：$$(21)L(w,b,\alpha,\xi,\mu)=\frac{1}{2}||w||^2+C\sum_{i=1}^m\xii+\sum{i=1}^m\alpha_i(1-\xi_i-y_i(w^Txi+b))-\sum{i=1}^m\mu_i\xi_i$$ 其中$\alpha_i\geq0,\mu_i\geq0$为拉格朗日乘子。 对$L(w,b,\alpha,\xi,\mu)​$中的$w​$,$b​$和$\xi​$求偏导得出下式：$$(22)w = \sum_{i=1}^m\alpha_iy_ix_i,$$ $$(23)0=\sum_{i=1}^m\alpha_iy_i,$$ $$(24)C=\alpha_i+\mu_i$$ 将$(22)(23)(24)$带入$(21)$可以得到$(20)$的对偶问题：$$(25)\max\alpha\sum{i=1}^m\alphai-\frac{1}{2}\sum{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j$$ $$(26)s.t.\sum_{i=1}^m\alpha_iy_i=0, 0\le\alpha_i\le C$$ 线性可分支持向量机和线性支持向量机两者的对偶问题进行比较可知，两者唯一的差别就是对偶函数的约束不同，对于线性可分支持向量机来说，约束条件为$0 \le \alpha_i$而线性支持向量机的约束条件为$0 \le \alpha_i \le C$。从这也可以看出，线性可分支持向量机是线性支持向量机在C区域正无穷的时候的值。 类似之前的求解，对于线性支持向量机，其KKT条件要求如下：$$(27.1)\alpha_i\ge0,\mu\ge0,$$ $$(27.2)y_if(x_i)\ge1-\xi_i$$ $$(27.3)\alpha_i(y_if(x_i)-1+\xi_i)=0$$ $$(27.4)\xi_i\ge0,u_i\xi_i=0$$ 由(27.3)得，对于任意一个训练样本均有$\alpha_i=0$或者$y_if(x_i)-1+\xi=0$如果$\alpha_i=0$则该训练样本不会对结果造成影响。如果$\alpha_i&lt; C$则$\mu_i&gt;0$那么必有$\xi_i=0$那么此时就代表该向量为支持向量，就在可分边界上。如果$\alpha_i=C$那么$\mu_i=0$,此时若$\xi_i1$则被错误分类。 这里的求解方法也和线性可分支持向量机类似，可以利用SMO对其进行求解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[支持向量机-线性可分支持向量机]]></title>
      <url>%2F2017%2F05%2F06%2F%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-%E7%BA%BF%E6%80%A7%E5%8F%AF%E5%88%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[介绍支持向量机是一种很好的机器学习方法，在面试中多次被用到。 支持向量机本质上是一个二分类模型，其基本问题为在训练集D在样本空间找到一个超平面，使得这个超平面起到最好的分类效果。可是何谓最好呢？在支持向量机里面最好的定义就是“最小的取最大”这里的最小即为两种分类到分界面的距离最小，而最优的份界面的选择就是要使得这里的到分界面距离最小的值取取最大的支持向量。而到中间距离最小的点即为支持向量。 支持向量机有三类，分别是线性支持向量机，线性可分支持向量机和非线性支持向量机。 线性可分支持向量机基本思想线性可分支持向量机我们重点介绍，他是线性支持向量机和非线性支持向量机的基础。在样本空间中，划分超平面的方程的表示形式如下所示： ​ $$(1)w^Tx + b = 0 $$ 其中$w^T$ = ($w_1;w_2;w_3;….;w_d$)为法向量决定了该划分超平面的距离，而b为原点距决定了超平面与原点间的距离。由此可知，划分超平面可以由法向量 $w$ 和原点距位移 $b$所确定，所确定的超平面计为$(w,b)$,则样本空间内的一点$x$到$(w,b)$的距离可以写为 ​ $$(2)r=\frac{|w^Tx + b|}{||w||}$$ 如果有一点可以被正确分类，那么不难知道如果他的x满足$ w^Tx_i + b &gt; 0 $时$ y_i = +1 $,$ w^Tx_i + b &lt; 0 $时$ y_i = -1 $ 而如果我们在这里把0的标准换位1和－1的标准，令以下成立：$$(3)w^Tx_i + b =&gt; 1 ; y_i = +1 ; w^Tx_i + b &lt;= -1 ; y_i = -1$$在使这里的大于等于和小于等于号为等号时满足的条件为支持向量。 线性可分支持向量机这里使用的是硬间隔，即在间隔中不允许存在分类点，而线性支持向量机使用的是软间隔这也是线性可分支持向量机和线性支持向量机的区别所在。 由上面知道，如果当等号成立时取支持向量。那么当他取支持向量的时候其距离为 $ y=\frac{2}{||w||}$。而我们寻找的就是使下列条件成立时的$w$和$b$的值，该数值可以使得$y$为最大。那么其约束条件为下式：$$(4)\max_{w,b}\frac{2}{||w||}$$$$(5)s.t.y_i(w^Tx_i+b) \geq 1, i =1,2,3……m.$$ 而若要求$\frac{1}{||w||}$的最大值，那么就是要求$||w||$的最小值。则就可以将上述的$(4)$式改写为以下形式：$$(6)\min_{w,b}\frac{1}{2}||w||^2\$$则5，6式即为支持向量机的基本型，其也为线性可分向量机的基本形态。 凸优化问题上式为一个凸二次规划问题，凸优化问题是指约束最优化问题$$\min_wf(w)$$ $$s.t.g_i(w)\le0,i=1,2,3….k;h_i(w)=0,i=1,2,3…l$$ 其中，目标函数$f(w)$和约束函数$g_i(w)$是$R^n$上连续的可微的凸函数，$h_i(w)$是R^n上的访射函数。当$f(w)$是二次函数且约束函数$g_i(w)$为访射函数时，上述凸优化问题就会变为凸二次规划问题。 公式求解对于以上$(5)(6)$两式，在这里可以使用拉格朗日乘子法对其进行求解，对于$(5)$式的每条约束，我们都可以添加拉格朗日乘子$\alphai \geq 0$,那么该问题的拉格朗日函数就可以写成以下式子：$$(7)L(w,b,\alpha) = \frac{1}{2}||w||^2 + \sum{i=1}^m\alpha_i(1-y_i(w^Txi+b))$$接下来用拉格朗日乘子法的套路，使用$L(w,b,\alpha)$对其进行求偏导的过程，即可消去$w$和$b$，可得他的对偶问题$(10)$：$$(8)w = \sum{i=1}^m\alpha_iy_ixi\(9)0 = \sum{j=1}^m\alpha_iyi ;\(10)max\alpha \sum_{i=1}^m\alphai - \frac{1}{2}\sum{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Txj$$对$\alpha$求解后，即可求出$w$和$b$的模型：$$(12)f(x) = w^Tx + b = \sum{i=1}^m\alpha_iy_ix_i^Tx_i＋b$$ 由以上约束可知，其满足KKT条件即：$$(13)\alpha_i \geq 0 ; y_if(x_i)-1\geq0; \alpha_i(y_if(x_i)-1)=0$$于是对于所有的点可知，要么满足$\alpha_i$=0或者$y_if(x_i)=1$对于支持向量的点即为$y_if(x_i)=1$，对于其他点就为$\alpha_i$=0。而训练所需的为支持向量点，其余点就可忽略，最终模型仅仅和支持向量有关系。 求解方法——SMO算法确定$\alpha$方法SMO方法的思想在于，除了两个变量$\alpha_i$和$\alpha_j$其余变量全部固定，然后重复下列两部获得更新后的$\alpha_i$和$\alpha_j$: 选取两个需要更新的$\alpha_i$和$\alpha_j$； 固定$\alpha_i$和$\alpha_j$外的其他参数，求解更新后的$\alpha_i$和$\alpha_j$； 只要选取的$\alpha_i$和$\alpha_j$有一个不满足KKT条件，那么目标函数就会在迭代后变得更小。一般SMO选取为两个差别很大的变量，对他们进行变化会得到更好的效果。 对于SMO的方法，由$L(w,b,\alpha)$对$b$求偏导可知$(9)$所以不难得出下式:$$(14)\alpha_iy_i+\alpha_jyj+c = 0 ; c=\sum{k=0,k!=i,j}^m\alpha_ky_k$$其中$\alpha_i$和$\alpha_j$可以相互表示，那么假设用$\alpha_i$将$\alpha_j$表示后，带入(10) 后仅有一个参数，因此就很好计算$\alpha_i$ 求解$b$的方法对于所有的支持向量都有$,y_sf(x_s)=1$即：$$(15)ys(\sum{i}\alpha_iy_ix_i^Txs+b)=1$$通过此式子就可以求出b，原则上可以使用任意一个式子来求b，但一般使用的为多个求平均值的方法来做:$$(16)b=\frac{1}{|S|}\sum{s\epsilon S}(ys-\sum{i\epsilon S}\alpha_iy_ix_i^Tx_i)$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 9. (E)Palindrome Number]]></title>
      <url>%2F2017%2F05%2F06%2FLeetCode-9-E-Palindrome-Number%2F</url>
      <content type="text"><![CDATA[题目描述Determine whether an integer is a palindrome. Do this without extra space. 方法描述此题较为简单，给出两种解法。 解法一首先第一种的解法和LeetCode 7类似，具体来看就是求出LeetCode 7的结果再和本题的输入做比较，若两者相等就输出正确，两者不等就输出错误。值得注意的一点是，所有负数都不是回文数因此在此处多加留意即可。 解法二解法二的思路是将每个数字的第一位和最后一位相继比较。如果全部相同则返回正确，有一个不同就返回错误。解法二使用一个表达位数的变量(number)老计算数字的头部。用%10取余的形式计算低位。 代码实现解法一1234567891011121314151617181920class Solution &#123;public: bool isPalindrome(int x)&#123; int y = x; if(x &lt; 0) return false; if(x == 0) return true; int reverse = 0; while(x &gt;= 1)&#123; int new_reverse = 0; new_reverse = reverse * 10 + x % 10; if(((new_reverse - x % 10) / 10) != reverse) return false; reverse = new_reverse; x = x / 10; &#125; if(reverse == y) return true; if(reverse != y) return false;&#125;&#125;; 解法二12345678910111213141516171819class Solution &#123;public: bool isPalindrome(int x)&#123; if(x &lt; 0) return false; if(x == 0) return true; int div = 1; while(x / div &gt;= 10)&#123; div *= 10; &#125; while(x != 0)&#123; int l = x / div; int n = x % 10; if (l != n) return false; x = (x % div) / 10; div /= 100; &#125; return true;&#125;&#125;; 补充解法二提供了一种很好的掐头去尾的做法，这种做法可以当作一个套路应用数字求解问题中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 7. [E]Reverse Integer]]></title>
      <url>%2F2017%2F05%2F06%2FLeetCode-7-Reverse-Integer%2F</url>
      <content type="text"><![CDATA[题目描述Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 算法描述这道题是easy题，题目本身没有什么难度。但是对于溢出检测这一点的确让人伤了不少脑筋。也许这也是这道题要考察大家的点吧。 主要的算法就是下面这句: 1result = result * 10 +x % 10 完成代码版本11234567891011121314151617class Solution &#123;public:int reverse(int x) &#123; int y = abs(x); int result = 0; while(y &gt;= 1)&#123; int newresult = result * 10 + y % 10; if(((newresult - y % 10) / 10) != result) return 0; y = y / 10; result = newresult; &#125; if(x == 0) return 0; if(x &gt; 0) return result; if(x &lt; 0) return -result;&#125;&#125;; 版本212345678910111213141516171819class Solution &#123;public:int reverse(int x) &#123; int result = 0; while(x != 0 )&#123; if(result &gt; INT_MAX / 10 || ((result == INT_MAX / 10) &amp;&amp; (result % 10 &gt; INT_MAX / 10))) &#123; result = 0; break; &#125; if(result &lt; INT_MIN / 10 || ((result == INT_MIN / 10) &amp;&amp; (result % 10 &lt; INT_MIN % 10)))&#123; result = 0; break; &#125; result = result * 10 + x % 10; x = x / 10; &#125; return result;&#125;&#125;; 补充本题目处理溢出的方法方法一直接用long类型就不会溢出，这种方法比较讨巧，不建议用。 方法二不用任何flag和INT_MAX的方法，只要比较一下最后输出得到的值和原来的值是否一样即可。若溢出了，则对于溢出后的值做反向操作后的值会和原来不一样。本题实现方法一的代码即用的此思路。 方法三方法三即为提前停止操作。即如果当前的数目已经大于INT_MAX/10了 那么再做一次操作，则结果必然溢出。因此代码实现二即用的此方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode [M]2.Add Two Numbers]]></title>
      <url>%2F2017%2F05%2F03%2FLeetCode2%2F</url>
      <content type="text"><![CDATA[题目描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 算法描述本题目的意思是给出两个非空的链表，对两个链表进行相加，之后返回相加的值，值得注意的是这两个非空的链表为逆序的，其第一位表示个位。正如上面例子所给，即为342 + 465 ＝ 807。 C++版本1C++ 版本1的代码即为最原始的思路，即把其分为四种情况，分别是L1和L2均不为空，L1为空L2不为空，L2为空L1不为空和进位不为。再对每种情况进行观察。最终得到的结果。 C++版本2c++版本2的代码构建了一个while循环，在循环内部先测试L1,若L1不为空则将L1的值加入，加入后再指向下一个L1的值。L2同L1,经历一次后即可得到一个数位p -&gt; var。之后再将计算进位的值，进行下一轮。 完成代码C++版本11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution&#123;public: ListNode *addTwoNumbers(ListNode *l1,ListNode *l2)&#123; if(!l1) return l2; if(!l2) return l1; ListNode *head = new ListNode(0); ListNode *ret = head; ListNode *p = head; int nCarry = 0; while(l1 &amp;&amp; l2)&#123; int a = l1 -&gt; val; int b = l2 -&gt; val; int c = a + b + nCarry; nCarry = c / 10; p -&gt; next = new ListNode(c % 10); p = p -&gt; next; l1 = l1 -&gt; next; l2 = l2 -&gt; next; &#125; while(l1)&#123; int a = l1 -&gt; val; int b = 0; int c = a + b + nCarry; nCarry = c / 10; p -&gt; next = new ListNode(c % 10); p = p -&gt; next; l1 = l1 -&gt; next; &#125; while(l2)&#123; int a = 0; int b = l2 -&gt; val; int c = b + nCarry; nCarry = c / 10; p -&gt; next = new ListNode(c % 10); p = p -&gt; next; l2 = l2 -&gt; next; &#125; if(nCarry)&#123; p -&gt; next = new ListNode(1); nCarry = 0; &#125; ret = ret -&gt; next; delete head; return ret; &#125;&#125;; C++版本2123456789101112131415161718192021222324class Solution&#123;public: ListNode *addTwoNumbers(ListNode *l1,ListNode *l2)&#123; ListNode *head = new ListNode(0); ListNode *p = head; int nCarry = 0; while(1)&#123; if(l1)&#123; nCarry += l1 -&gt; val; l1 = l1 -&gt; next; &#125; if(l2)&#123; nCarry += l2 -&gt; val; l2 = l2 -&gt; next; &#125; p -&gt; val = nCarry % 10; nCarry /= 10; if(l1 != NULL || l2 != NULL || nCarry != 0)&#123; p = (p -&gt; next = new ListNode(0)); &#125;else break; &#125; return head; &#125;&#125;; Java版本12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; ListNode head = new ListNode(0); ListNode point = head; int carry = 0; while(l1 != null &amp;&amp; l2!=null)&#123; int sum = carry + l1.val + l2.val; point.next = new ListNode(sum % 10); carry = sum / 10; l1 = l1.next; l2 = l2.next; point = point.next; &#125; while(l1 != null) &#123; int sum = carry + l1.val; point.next = new ListNode(sum % 10); carry = sum /10; l1 = l1.next; point = point.next; &#125; while(l2 != null) &#123; int sum = carry + l2.val; point.next = new ListNode(sum % 10); carry = sum /10; l2 = l2.next; point = point.next; &#125; if (carry != 0) &#123; point.next = new ListNode(carry); &#125; return head.next; &#125;&#125; python版本1234567891011121314151617181920class Solution(object): def addTwoNumbers(self, l1, l2): head = ListNode(0) ptr = head carry = 0 while True: if l1 != None: carry += l1.val l1 = l1.next if l2 != None: carry += l2.val l2 = l2.next ptr.val = carry % 10 carry /= 10 if l1 != None or l2 != None or carry != 0: ptr.next = ListNode(0) ptr = ptr.next else: break return head]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux学习之软件包管理]]></title>
      <url>%2F2017%2F04%2F20%2Fhello%2F</url>
      <content type="text"><![CDATA[软件包系统linux系统主流软件包系统类， 软件包系统 发行版本 Debian类(.deb技术) Debian、Ubuntu等 Red Hat类(.rpm技术) Red Hat、CentOS等 其他 其他 软件包系统工具低级下载工具和高级下载工具的区别，对于低级下载工具来说。他并不是从库源下载来的，所以他并不会处理依赖问题，当dpkg过程中发现缺少依赖包的情况，那么就会报错。 发行版本 低级下载工具 Cool Debian类 dpkg apt-get、aptitude Red Hat类 rpm yum 软件包常用命令(以Debian类为例，因为常使用的版本为ubuntu) 功能 命令 查找软件包 apt-cache search search_string 安装软件包 apt-get install package_name 安装软件包文件中的软件包 dpkg —install package_file 删除软件包 apt-get remove package_name; 移除软件包(比删除更加彻底) apt-get purge package_name 更新软件包 apt-get update(upgrade) 列出软件包命令 dpkg —list 判断是否安装命令 dpkg —status package_name 显示安装包相关信息 apt-cache show package_name`]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用python把几个词语的某一位变为大写]]></title>
      <url>%2F2017%2F04%2F20%2F%E5%88%A9%E7%94%A8python%E6%8A%8A%E5%87%A0%E4%B8%AA%E8%AF%8D%E8%AF%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%BD%8D%E5%8F%98%E4%B8%BA%E5%A4%A7%E5%86%99%2F</url>
      <content type="text"><![CDATA[缘起晚上女票发给我一段她写的代码.该代码的作用是把字符串中的首字母从小写改为大写。结果产生了一定的问题，即它把所有和首字母一样的字母全部都变成了大写。代码乍一看没什么问题，但是仔细debug后发现了其中的问题所在 代码解释1234567891011#定义一个函数，该函数的功能为将输入多个单词的首位的字母由小写改为大写def LetterCapitalize(str): #先将输入的多个单词分成一个一个的小单词 wordlist=str.split()#再定义一个新的字符串，该字符串用于存放修改好的多个单词 newstr=''#对每个单词进行便利，并将首字母(word[0])被他的大写字母替代掉,最后再将替换好的字母连接起来返回 for word in wordlist: newword=word[0].upper()+word[1:] return " ".newwordprint LetterCapitalize(raw_input()) 这个代码看似没有问题，但是当测试时有问题，比如我们输入”helloh worldwa”则输出就会变为”HelloH WorldWa”这与预计完全不符。这个的原因是因为在下面word[0]本质上已经被赋值成为了h这里这段代码的意思等价于： 1word=word.replace(h,h.upper()) 因此这是主要问题所在。 另外这个代码还有问题即为输出的前面总是多一个空格，因为刚开始相当于是””+” “的形式。 正确代码1234567891011#正确代码如下，他将整个wordlist看成一个列表，列表中的每个单词为一个元素，并将元素分开处理。分为首部和去掉首部后的其他部分，和刚刚的改动之处为重新将1～len(word)的数据写了一遍这样就可以正确显示了。最终处理时，将首字母的第两个个空格略去，即可得到想要的结果def LetterCapitalize(str):wordlist = str.split()newword = ''for word in wordlist:newword = newword + " " + word[0].upper() + word[1:]result = " " + newwordreturn result[2:]print LetterCapitalize(raw_input())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SVM]]></title>
      <url>%2F2017%2F04%2F16%2FSVM%2F</url>
      <content type="text"><![CDATA[介绍支持向量机是一种很好的机器学习方法，在面试中多次被用到。 其基本问题为在训练集D在样本空间找到一个超平面，使得这个超平面起到最好的分类效果。可是何谓最好呢？在支持向量机里面最好的定义就是“最小的取最大”这里的最小即为两种分类到分界面的距离最小，而最优的份界面的选择就是要使得这里的到分界面距离最小的值取取最大的支持向量。而到中间距离最小的点即为支持向量。 支持向量机有三类，分别是线性支持向量机，线性可分支持向量机和非线性支持向量机。 线性可分支持向量机基本思想线性可分支持向量机我们重点介绍，他是线性支持向量机和非线性支持向量机的基础。在样本空间中，划分超平面的方程的表示形式如下所示： ​ $$(1)w^Tx + b = 0 $$ 其中$w^T$ = ($w_1;w_2;w_3;….;w_d$)为法向量决定了该划分超平面的距离，而b为原点距决定了超平面与原点间的距离。由此可知，划分超平面可以由法向量 $w$ 和原点距位移 $b$所确定，所确定的超平面计为$(w,b)$,则样本空间内的一点$x$到$(w,b)$的距离可以写为 ​ $$(2)r=\frac{|w^Tx + b|}{||w||}$$ 如果有一点可以被正确分类，那么不难知道如果他的x满足$ w^Tx_i + b &gt; 0 $时$ y_i = +1 $,$ w^Tx_i + b &lt; 0 $时$ y_i = -1 $ 而如果我们在这里把0的标准换位1和－1的标准，令以下成立：$$(3)w^Tx_i + b =&gt; 1 ; y_i = +1 ; w^Tx_i + b &lt;= -1 ; y_i = -1$$在使这里的大于等于和小于等于号为等号时满足的条件为支持向量。 线性可分支持向量机这里使用的是硬间隔，即在间隔中不允许存在分类点，而线性支持向量机使用的是软间隔这也是线性可分支持向量机和线性支持向量机的区别所在。 由上面知道，如果当等号成立时取支持向量。那么当他取支持向量的时候其距离为 $ y=\frac{2}{||w||}$。而我们寻找的就是使下列条件成立时的$w$和$b$的值，该数值可以使得$y$为最大。那么其约束条件为下式：$$(4)\max_{w,b}\frac{2}{||w||}$$$$(5)s.t.y_i(w^Tx_i+b) \geq 1, i =1,2,3……m.$$ 而若要求$\frac{1}{||w||}$的最大值，那么就是要求$||w||$的最小值。则就可以将上述的$(4)$式改写为以下形式：$$(6)\min_{w,b}\frac{1}{2}||w||^2\$$则5，6式即为支持向量机的基本型，其也为线性可分向量机的基本形态。 公式求解对于以上$(5)(6)$两式，在这里可以使用拉格朗日乘子法对其进行求解，对于$(5)$式的每条约束，我们都可以添加拉格朗日乘子$\alpha_i \geq 0$,那么该问题的拉格朗日函数就可以写成以下式子： $$(7)L(w,b,\alpha) = \frac{1}{2}||w||^2 + \sum_{i=1}^m\alpha_i(1-y_i(w^Tx_i+b))$$ 接下来用拉格朗日乘子法的套路，使用$L(w,b,\alpha)$对其进行求偏导的过程，即可消去$w$和$b$，可得他的对偶问题$(10)$：$$(8)w = \sum_{i=1}^m\alpha_iy_ix_i$$ $$(9)0 = \sum_{j=1}^m\alpha_iy_i ;$$ $$(10)max_\alpha\sum_{i=1}^m\alpha_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j；$$ 对$\alpha$求解后，即可求出$w$和$b$的模型： $$(12)f(x) = w^Tx + b = \sum_{i=1}^m\alpha_iy_ix_i^Tx_i＋b$$ 由以上约束可知，其满足KKT条件即： $$(13)\alpha_i \geq 0 ; y_if(x_i)-1\geq0; \alpha_i(y_if(x_i)-1)=0$$ 于是对于所有的点可知，要么满足$\alpha_i$=0或者$y_if(x_i)=1$对于支持向量的点即为$y_if(x_i)=1$，对于其他点就为$\alpha_i$=0。而训练所需的为支持向量点，其余点就可忽略，最终模型仅仅和支持向量有关系。 求解方法——SMO算法确定$\alpha$方法SMO方法的思想在于，除了两个变量$\alpha_i$和$\alpha_j$其余变量全部固定，然后重复下列两部获得更新后的$\alpha_i$和$\alpha_j$: 选取两个需要更新的$\alpha_i$和$\alpha_j$； 固定$\alpha_i$和$\alpha_j$外的其他参数，求解更新后的$\alpha_i$和$\alpha_j$； 只要选取的$\alpha_i$和$\alpha_j$有一个不满足KKT条件，那么目标函数就会在迭代后变得更小。一般SMO选取为两个差别很大的变量，对他们进行变化会得到更好的效果。 对于SMO的方法，由$L(w,b,\alpha)$对$b$求偏导可知$(9)$所以不难得出下式: $$(14)\alpha_iy_i+\alpha_jy_j+c = 0 ; c=\sum_{k=0,k!=i,j}^m\alpha_ky_k$$ 其中$\alpha_i$和$\alpha_j$可以相互表示，那么假设用$\alpha_i$将$\alpha_j$表示后，带入(10) 后仅有一个参数，因此就很好计算$\alpha_i$ 求解$b$的方法对于所有的支持向量都有$,y_sf(x_s)=1$即： $$(15)y_s(\sum_{i}\alpha_iy_ix_i^Tx_s+b)=1$$ 通过此式子就可以求出b，原则上可以使用任意一个式子来求b，但一般使用的为多个求平均值的方法来做: $$(16)b=\frac{1}{|S|}\sum_{s\epsilon S}(y_s-\sum_{i\epsilon S}\alpha_iy_ix_i^Tx_i)$$ 线性支持向量机基本思想线性可分支持向量机很容易对两个区别明显且没有样本相交的情况下才能实现，现实生活中这种很理想的情况并不存在。在这些情况下线性可分支持向量机就失效了；即使可以通过线性可分支持向量机对其进行很好的分类，但是他所训练出的模型也很容易产生过拟合，于是这里就要使用线性支持向量机。 上面说过，线性支持向量机和线性可分支持向量机最大的区别在于线性可分支持向量机所用的为硬间隔,线性支持向量机采用的是软间隔。软间隔的表示如下图所示： 软间隔和硬间隔最最大的区别在于对于软间隔来说，并不需要所有的样本都能划分正确。不一定满足约束条件: $$y_i(w^Tx_i+b)\geq 1$$ 而在能满足的情况下，当然需要不满足的样本尽可能的少。所以对于线性可分支持向量机来说，优化目标为： $$(17)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^ml_{0/1}(y_i(w^Tx_i+b)-1)$$ 其中$C&gt; 0$为一个常数，而$l_{0/1}(z)$为“0/1损失函数”,当$z&lt;0$时为1，其余时候为0。 由上面的式子可知，如果$C$的值过于大，那么他在每次犯错后所要付出的代价就会很大，而C很小时其每次所需的代价就比较小。于是我们极端来看不难得出当C为无限小为0时，他随便犯错都无所谓，这时候线性支持向量机的作用就失去了。而当$C$为无限大的时候，这时候犯一点错误就会受到很大的惩罚，这时候一点错误都不敢犯。因此当$C$为无限大时，线性支持向量机就变为了线性可分支持向量机。不难看出，线性可分支持向量机是线性支持向量机在$C$为无穷大时的一种特例。 但是在实际的应用场景中，$l{0/1}(z)$损失的数学性质不好，非凸函数且非连续函数。因此$(17)$式不好求解，这时候在支持向量机中荷叶损失函数(hinge损失)：$$(18)l{hinge}(z)=\max(0,1-z);$$当把$l{0/1}(z)$损失函数变成了$l{hinge}(z)$损失函数后，则$(17)$式变为下式$(19)$在引入松弛因子后，就成了$(20)$式：$$(19)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\max(0,1-y_i(w^Tx_i))$$ $$(20.1)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\xi_i$$ $$(20.2)s.t. y_i(w^Tx_i+b)\geq 1-\xi_i;\xi_i\geq0,i=1,2,3…m.$$ 如上图所示，上图分别为hinge函数损失函数，指数损失函数和对率损失函数。这三种损失函数的发展趋势都是一样的，但是在支持向量机中中，由于只要是等于1就算支持向量，原则上在其等于1时不能有损失，而指数损失函数和对率损失函数在等于1甚至是大于1时都有损失。因此在线性支持向量机中使用最多的是hinge损失函数，在有的教材中hinge损失函数也叫做SVM损失函数。 公式求解除了线性可分支持向量机用的是硬间隔，线性支持向量机用的是软间隔外，在其余方面这两个线性支持向量机差别不大，因此对于其公式求解，也使用如同线性可分支持向量机的求解方法，即用拉格朗日乘子法。类比公式$(7)$不难得出线性支持向量机的拉格朗日函数：$$L(w,b,\alpha,\xi,\mu)=\frac{1}{2}||w||^2+C\sum_{i=1}^m\xii+\sum{i=1}^m\alpha_i(1-\xi_i-y_i(w^Txi+b))-\sum{i=1}^m\mu_i\xi_i$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux学习之：定制shell提示符]]></title>
      <url>%2F2017%2F04%2F16%2FLinux%E5%AD%A6%E4%B9%A0%E4%B9%8B%EF%BC%9A%E5%AE%9A%E5%88%B6shell%E6%8F%90%E7%A4%BA%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[在系统初始化提示符的时候，提示符的样子如下: haoz@linux:~$ 通过以下命令可以查到PS1的值 修改命令提示行的样式1echo $PS1 再通过下图所示的shell提示符中使用的转义字符即可对shell提示符进行自己想要的修改命令: 修改命令提示行的颜色除了自定义命令行的显示类型外，还可以定义命令行的现实颜色，具体代码如下： 1PS1=&quot;\[\033[0;41m\]&lt;[\w]\u@\h$:&gt;\[\033[0m\]&quot; 此命令可以将命令行的背景换为红色 更改41m可以将其换位其他颜色。 修改命令提示行的光标位置1PS1=&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;[\w]\u@\h$:&gt;&quot; 此命令行的作用在每输入一行时，屏幕上方会出现一个红色的横条，横条中用黄色显示文本的时间。 下方命令对应光标移动转移序列的对应关系： 保存命令行要想把修改好的命令行永久的保存起来，就得把他存在某个地方，这里就是要存在.bashrc文件中。即将下列命令行添加到文件中： 12PS1=&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;[\w]\u@\h$:&gt;&quot;export PS1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux学习之：vi使用简介]]></title>
      <url>%2F2017%2F04%2F15%2FLinux%E5%AD%A6%E4%B9%A0%E4%B9%8B%EF%BC%9Avi%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[12# 进入vi界面$ vi vi命令模式点击esc即可进入vi的命令模式 在这里可以进行一系列命令对vi进行操作 比如说保存，关闭，查找等命令 :w 保存命令 L或者右箭头：右移动 H或者左箭头：左移动 J或者下箭头：下移动 K或者上箭头：上移动 数字0:至本行开头 Ctrl-F或者page down：下翻一页 Ctrl-B或者page up：上翻一页 shift+g：至文件的最后一行 number＋g：至文件的第number行 /:对文本进行搜索 {[%],[1,\$][1,5]}s/A/B/g(其中前面表示从多少行到多少行，%表示从第一到最后，[1,$]表示从1到最后,[1,5]表示从1到5行；s表示命令为替换操作，即搜索和替换；A表示要被替换成的语句；B为要替换的语句；g即为全局搜索) 使用n切换到下一个文件，使用N切换到上一个文件 使用buffers展示文件 r：读入文件 vi编辑模式1.进入插入模式 点击i即进入插入模式 点击o在上方插入 点击O在下方插入 点击x删除当前字符 点击“number”+x删除当前字符和之后number－1个字符 点击dd剪切当前行 点击yy复制当前行 点击p粘贴 点击“number”+dd删除当前行和后面的number－1行 点击J命令移动合并行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之抽象工厂模式]]></title>
      <url>%2F2017%2F01%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[抽象工厂模式抽象工厂模式概念简单工厂模式和工厂方法模式的本质是给入不同的属性，通过不同的属性调用不同的类从而得到不同的对象。而抽象工厂模式可以将一组具有同样主题的工厂封装起来，在简单工厂模式前加一层抽象的概念。即抽象工厂模式是一个父类工厂，通过该抽象工厂模式产生具体工厂。抽象工厂模式即为工厂的工厂。 抽象工厂模式有四种角色： 抽象工厂：担任这个角色的是工厂方法模式的核心，它是与应用系统商业逻辑无关的。 具体工厂：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统的商业逻辑紧密相关的。 抽象产品：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。 具体产品：这个角色用以代表具体的产品。 抽象工厂模式类图这里我们定义一个抽象工厂为”University”。通过这个抽象工厂生成两个具体工厂为”BUPT”和”BNU”。其中BUPT 中男生偏多且毕业生大都为工程师，所以从BUPT中生产的产品为”Boy”和”Engineer”。而BNU中女生偏多且很多毕业生做教师，于是从BNU这个工厂生产的产品为”Girl”和”Teacher”. 抽象工厂模式代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface University&#123; public Sex getSex(); public Job getJob();&#125;public interface Sex&#123; public String getSexName(); &#125;public interface Job&#123; public String getJobName(); &#125;public class BUPT implements University&#123; public Sex getSex()&#123; return new Boy(); &#125; public Job getJob()&#123; return new Engineer(); &#125;&#125;public class Engineer implements Job&#123; public String getJobName()&#123; return "engineer"; &#125;&#125;public class Boy implements Sex&#123; public String getSexName()&#123; return "boy"; &#125;&#125;public class Student&#123; public void graduate(University s)&#123; System.out.println("A graduate student is a "+s.getSex().getSexName()+" and he/she get a job of "+s.getJob().getJobName(); &#125; public static void main(String[] args)&#123; Student s = new Student(); University u = new BUPT(); s.graduate(u); &#125;&#125; 产品等级结构和产品族产品等级结构产品等级结构即产品的继承结构。比如一个抽象类为球类运动，其子类有足球、篮球等；则球类运动和篮球、足球就构成了一个产品等级结构。其中抽象的球类运动为父类，具体的球类运动为子类。 产品族在抽象工厂模式中，产品族是由同一个工厂产生，但位于不同产品等级结构中的一组产品。比如说上面的例子，产品Boy和产品Engineer都是BUPT这个工厂生产出来的。但是Boy这个产品是和Sex这个抽象父类构成一个产品等级结构，Engineer这个产品是和Job这个抽象父类构成一个产品等级结构。Boy和Engineer组成了一个产品族。 由产品族和产品等级结构就可以唯一的确定一个产品。 抽象工厂模式和工厂方法模式的区别介绍完了产品等级结构和产品族后，抽象工厂模式和工厂方法模式的区别就很明显了。工厂方法模式针对的是一个产品等级，而抽象工厂模式是针对多个产品等级。当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>%2F2017%2F01%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[设计模式之工厂模式工厂模式在面向对象的设计中，其是一个用于创建其他对象的对象。其根据不同的参数来创建不同的对象并实现不同的分配方案。例如创建“人”这个对象，输入男女的特征，工厂模式就为我们创建男人/女人。(上帝即视感！) 工厂模式分为三类： 简单工厂模式 工厂模式方法 抽象工厂模式 此篇先介绍简单工厂模式和工厂模式方法 工厂模式类图：这里我们就使用工厂模式来造人，我们先造一个男人，他每天的工作是吃饭睡觉打豆豆，顺便再踢踢球。而我们再造一个女人，那么她每天的工作也是吃饭睡觉打豆豆，顺便再买买买！下面就是该UML的类图： 简单工厂模式示例代码简单工厂模式代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//抽象产品——人类 有eat,sleep,beat方法abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat();&#125;//具体产品--男人 有eat,sleep,beat,soccer方法class Male extends Human&#123; public void eat()&#123; System.out.println("Man can eat."); &#125; public void sleep()&#123; System.out.println("Man can sleep."); &#125; public void beat()&#123; System.out.println("Man can beat doudou."); &#125;&#125;//具体产品--女人 有eat,sleep,beat,buy方法class Female extends Human&#123; public void eat()&#123; System.out.prinln("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125;&#125;/*简单工厂模式，当性别为male时构建男生方法当性别为female时构建女生方法*/public class HumanFactory&#123; public static Human createHuman(String gender)&#123; Human human = null; if(gender.equals("male")&#123; human = new Man(); &#125;else if(gender.equals("female"))&#123; human = new Female(); &#125; return human; &#125; &#125;/*女娲造人方法，用该方法造一个男人，再造一个女人*/public class Goddess&#123; pubic static void main(String[] args) throws IOException&#123; Human man = HumanFactory.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); Human woman = HumanFactory.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125;&#125; 工厂方法模式示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//抽象产品--人类abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat(); &#125;//具体产品--男人，他有吃饭，睡觉，打豆豆以及看足球的方法class Male extends Human&#123; public void eat()&#123; System.out.println("Male can eat."); &#125; public void sleep()&#123; System.out.println("Male can sleep."); &#125; public void beat()&#123; System.out.println("Male can beat doudou."); &#125; public void soccer()&#123; System.out.println("Male can play soccer."); &#125;&#125;//具体产品--女人，她有吃饭，睡觉，打豆豆及买买买的需求class Female extends Human&#123; public void eat()&#123; System.out.println("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125; public void buy()&#123; System.out.println("Female can buy"); &#125;&#125;//从这里开始使用工厂方法模式//定义一个抽象工厂类Humanabstract class HumanFactory&#123; public abstract Human createHuman(String gender) throws IOException&#123; return new Human(); &#125;&#125;//定义一个具体工厂类Female,来生产女人class FemaleFactory extends HumanFactory&#123; public Human createHuman(String gender) throws IOException&#123; return new Female(); &#125;&#125;//定义一个具体工厂类Male,来生产男人class MaleFactory extends HumanFactory&#123; public Male createHuman(String gender) throws IOException&#123; return new Male(); &#125;&#125;//定义一个上帝主类，开始造人public class Goddess&#123; public static void main(String[] args) throws IOException&#123; //创造男人 HumanFactory hfm = new MaleFactory(); Human man = hfm.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); //创造女人 HumanFactory hff = new FemaleFactory(); Human woman = hff.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125; 工厂模式用处工厂模式虽然思想简单，但是在java中有很多的用处。比如说在Java库中，根据输入不同的参数类型对象，getInstance()方法就会返回不同的结果。这里就使用了工厂模式的知识。 123456java.util.Calendar-getInstance()java.util.Canlendar-getInstance(TimeZone zone)java.util.Canlendar-getInstance(Locate aLocale)java.util.Canlendar-getInstance(TimeZone zone,Locate aLocale)java.text.NumberFormat-getInstance()java.text.NumberFormat-getInstance(Locate inLocate)]]></content>
    </entry>

    
  
  
</search>
