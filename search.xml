<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[汉诺塔问题]]></title>
      <url>%2F2017%2F06%2F16%2F%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[算法描述有三根相邻的柱子，标号为A,B,C,A的柱子按从大到小叠放着n个不同大小的盘子，按要求把所有的盘子每次移动一个，最终都放到C柱子上，移动过程可以借助B柱子，但每次都要保持小盘子在大盘子上面。请给出最少次数的移动方案。 问题思考汉诺塔是一个经典的用于理解递归调用的例子。 可以将整个n个盘子看成两部分，上面的n-1盘子是一个部分，下面的1个盘子是一个部分。那么完成一次移动就有三步，第一步先将前n-1个盘子移动到中转轴上面，然后再将最下面的盘子移动到目标轴上，之后再将n-1个盘子从中转轴上面移动到目标轴上面。最终完成移动。以上步骤可以通过递归完成。 数学推导通过以上分析可以利用数学推导知道要移动n个盘子需要$2^n-1$个步骤。$$T(n)=2T(n-1)+1$$ $$T(n) + 1 = 2(T(n-1)+1)$$ $$\frac{T(n)+1}{T(n-1)+1}=2$$ $$T(n)=2^n - 1$$ 代码实现1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;void MoveOne(char from,char to);void Move(char from,char to,char aux,int n);int main()&#123; Move('A','B','C',4); return 0;&#125;void Move(char from,char to,char aux,int n)&#123; if(n == 1)&#123; MoveOne(from,to); return; &#125; Move(from,aux,to,n-1); MoveOne(from,to); Move(aux,to,from,n-1);&#125;void MoveOne(char from,char to)&#123; cout &lt;&lt; from &lt;&lt; "-&gt;" &lt;&lt; to &lt;&lt; endl;&#125; 进阶问题:汉诺塔的状态给定从小到大的N个盘子，它们散乱的位于A,B,C柱上，问这一状态能否将这N个盘子从A借助B移动到C的必经状态？如果是，则返回是第几个状态，如果不是那么返回-1 问题思考根据以上思考可以知道我们将汉诺塔问题分为三步，那么通过了解最下面盘子的状态就可以知道现在在进行到了哪一步。如果最下面盘子在初始轴上，那么就是在第一步或第二步，如果在目标轴上，那么他就在第三步。在计算的基础上加上$2^n$就可以完成。如果他在中转轴上，则根本不可能是其中的步骤，返回-1. 代码实现123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;void MoveOne(char from,char to);void Move(char from,char to,char aux,int n);int Calc(const char* str,int size,char from,char to,char aux);int Calc(const char* str,int size,char from,char to,char aux)&#123; if(size == 0) return 0; if(str[size - 1] == aux) return -1; if(str[size - 1] == to)&#123; int n = Calc(str,size - 1,aux,to,from); if(n == -1) return -1; return (1 &lt;&lt; (size - 1)) + n; &#125; return Calc(str,size - 1,from,aux,to);&#125;int main()&#123;// Move('A','B','C',4);// return 0; char str[] = "ABC"; cout &lt;&lt; Calc(str,3,'A','C','B') &lt;&lt; endl;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eratosthenes筛选法]]></title>
      <url>%2F2017%2F06%2F12%2Feratosthenes%E7%AD%9B%E9%80%89%E6%B3%95%2F</url>
      <content type="text"><![CDATA[算法描述eratosthenes筛选法是一种古老的求解素数的方法，其思想为选取一个数，在1-N中晒掉各个数字的倍数，以此来完成筛选素数的筛选 步骤如下： 先筛出掉最小的数字2，再将2的倍数筛去；再筛出次小的数字3，再将3的倍数筛掉，然后再筛除掉5，再将队列中5的倍数筛掉。以此类推，最后得出所有的值。 值得注意的是，筛选的时候要从p^2开始筛选，因为之前p*(p-1),p*(p-2)……已经被筛除掉了。而且如果筛选的数字大于了$\sqrt p$那么就不用再筛了，比如我们要筛选100以内的素数，筛掉2,3,5,7后就不用再筛了。 代码实现12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;void Eratosthenes(bool *a,int n);int main()&#123; bool a[1000]; Eratosthenes(a,200); for(int i = 1;i &lt; 200;i++) &#123; cout &lt;&lt; a[i] &lt;&lt; '\t'; &#125; return 0;&#125;void Eratosthenes(bool *a,int n)&#123; a[1] = false; int i; for(i = 1;i &lt; n;i++)&#123; a[i] = true; &#125; int p = 2; int k = p * p; while(k &lt;= n)&#123; while(k &lt;= n)&#123; a[k] = false; k = k + p; &#125; p++; while(!a[p])&#123; p++; &#125; k = p * p; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 47.[M]Permutations II]]></title>
      <url>%2F2017%2F05%2F30%2FLeetCode-47-M-Permutations-II%2F</url>
      <content type="text"><![CDATA[题目描述Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations: 12345[ [1,1,2], [1,2,1], [2,1,1]] 算法描述本题相比于46题，改动只有一点点，在46题的时候输入的序列不允许出现重复。而47题的版本允许出现重复。算法一的代码就是在46题的代码基础上进行修改。 算法一:当其进行遍历的时候，我们如果之前和他有一个元素相同，那么我们就跳过这个元素，对下一个元素进行遍历。 增加的代码如下: 123456789bool IsDuplicate(vector&lt;int&gt;&amp; nums,int n,int t)&#123; while(n &lt; t)&#123; if(nums[n] == nums[t])&#123; return false; &#125; n++; &#125; return true;&#125; 算法二46题的实现方法是一种递归的方法，其核心代码是一串递归代码： 123456for(int i = begin; i &lt; size;i++)&#123; if(! IsDuplicate(nums,begin,i)) continue; swap(nums[begin],nums[i]); permuteMain(nums,begin+1); swap(nums[begin],nums[i]); &#125; 而我们在这里用非递归的算法实现46题目，用该非递归算法的方法不用考虑是否重复。 对于一个数字组成的字符串，他有最小的一个组合，他也有最大的一个组合。那么我们就从他最小的组合开始遍历，寻求下一个比现在这个大的元素，最后遍历到最大的那个字符串停止。通过这个步骤就可以实现字符串的全排列问题。通过这种方式实现的全排列问题，不用考虑他是否是重复的，不管是否重复都可以使用这个代码。 代码实现算法一实现:123456789101112131415161718192021222324252627282930313233class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt; res;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums)&#123; if(nums.size() == 0) return res; permuteMain(nums,0); return res;&#125;void permuteMain(vector&lt;int&gt;&amp; nums,int begin)&#123; int size = nums.size(); if(begin == size)&#123; res.push_back(nums); &#125; else &#123; for(int i = begin; i &lt; size;i++)&#123; if(! IsDuplicate(nums,begin,i)) continue; swap(nums[begin],nums[i]); permuteMain(nums,begin+1); swap(nums[begin],nums[i]); &#125; &#125;&#125;bool IsDuplicate(vector&lt;int&gt;&amp; nums,int n,int t)&#123; while(n &lt; t)&#123; if(nums[n] == nums[t])&#123; return false; &#125; n++; &#125; return true;&#125;&#125;; 算法二实现1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;bool GetNextPermutation(int *a,int size);void Reverse(int *from,int * to);void Print(int *p,int size);int main(int argc,char* argv[])&#123; int a[] = &#123;1,2,2,3&#125;; int size = sizeof(a)/sizeof(int); Print(a,size); while(GetNextPermutation(a,size)) Print(a,size); return 0;&#125;bool GetNextPermutation(int *a,int size)&#123; int i = size - 2; while((i &gt;= 0) &amp;&amp; (a[i] &gt;= a[i+1])) i--; if(i &lt; 0) return false; int j = size - 1; while(a[j] &lt;= a[i]) j--; swap(a[i],a[j]); Reverse(a+i+1,a+size-1); return true;&#125;void Reverse(int *from,int * to)&#123; int t; while(from &lt; to)&#123; t = *from; *from = *to; *to = t; from++; to--; &#125;&#125;void Print(int *p,int size)&#123; for(int i = 0;i &lt; size ;i++)&#123; cout&lt;&lt; p[i]; &#125; cout &lt;&lt; endl;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 46.[M]Permutations]]></title>
      <url>%2F2017%2F05%2F25%2FLeetCode-46-M-Permutations%2F</url>
      <content type="text"><![CDATA[题目描述Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations: 12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 算法描述这里采用的算法是交换元素的方法，采用的递归法实现该算法。 遍历字符串，将当前遍历的字符和首字符进行交换，调用本函数处理首字符后的子字符串，然后执行完毕后再次调换回来。这样不需要刻意的复制字符串。 1234for(i = start to end)循环1.swap2.递归调用(begin+1)3.swap back 代码实现123456789101112131415161718192021222324class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums)&#123; if(nums.size() == 0) return res; permuteMain(nums,0); return res; &#125;private: vector&lt;vector&lt;int&gt;&gt; res; void permuteMain(vector&lt;int&gt;&amp; nums,int begin)&#123; int size = nums.size(); if(begin == size)&#123; res.push_back(nums); &#125; else &#123; for(int i = begin; i &lt; size;i++)&#123; swap(nums[begin],nums[i]); permuteMain(nums,begin+1); swap(nums[begin],nums[i]); &#125; &#125; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LintCode 77 [M]最长公共子序列]]></title>
      <url>%2F2017%2F05%2F19%2FLintCode%2077-M-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目描述最长公共子序列的定义： 最长公共子序列问题是在一组序列（通常2个）中找到最长公共子序列（注意：不同于子串，LCS不需要是连续的子串）。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用。 https://en.wikipedia.org/wiki/Longest_common_subsequence_problem 样例给出“ABCD” 和 “EDCA”，这个LCS是 “A” (或 D或C)，返回1给出 “ABCD” 和 “EACB”，这个LCS是“AC”返回 2 算法描述本题是LCS问题。该问题是一个字符串中常常用到的问题，之前做过一道最长序列的题目，和这道题目看起来很像，不过难度比这道题低很多。因为那道题是连续的，只要发现一个不连续就将其删除就行。而这道题是不连续的。因此难度要大很多。 该题目只要求实现返回最长子序列的长度。下面代码一给出这道题的解法。代码二给出改进版，可以输出最长子序列。 这道题可以分为两步 首先第一步是构造一个矩阵，矩阵构造好了以后就可以得到最长子序列的长度。 第二步是遍历该矩阵，然后输出最长子序列。 矩阵图如下所示： 首先第一步是构造这个矩阵，如果横轴和纵轴的字符串字母相同，那么就把对角线左上角的值加1即可。如果横轴和纵轴的字符串字母不同，那么就挑选左边和上边的大者进行勾选。直至到达键盘的棋盘的右下角即可得到最长子序列的长度值。 在得到这个矩阵后，在从右下角开始遍历，先看这个格子所对应的行和列是否相同，相同的话就输出此相同值同时指向左上角的值，如果不相同则选取左边或者上边的值进行指向。重复以上过程，最后就可以得出最长公共子序列的值。 代码实现1234567891011121314151617181920212223242526272829303132class Solution &#123;public: /** * @param A, B: Two strings. * @return: The length of longest common subsequence of A and B. */ int longestCommonSubsequence(string A, string B) &#123; if(A == "" || B == "") return 0; int size1 = A.length(); int size2 = B.length(); vector&lt;vector&lt;int&gt;&gt; chess(size1 + 1,vector&lt;int&gt;(size2 + 1)); int i,j; for(int i = 0;i &lt;= size1 ;i++)&#123; chess[i][0] = 0; &#125; for(int j = 0;j &lt;= size2 ;j++)&#123; chess[0][j] = 0; &#125;// cout &lt;&lt; A[0] &lt;&lt; " " &lt;&lt; B[0];// return chess[size1-1][size2-1]; for(int i = 1;i &lt;= size1 ;i++)&#123; for(int j = 1;j &lt;= size2 ;j++)&#123; if(A[i - 1] == B[j - 1]) chess[i][j] = chess[i-1][j-1] + 1; else chess[i][j] = max(chess[i][j-1],chess[i-1][j]); &#125; &#125; return chess[size1][size2];&#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: /** * @param A, B: Two strings. * @return: The length of longest common subsequence of A and B. */string longestCommonSubsequence(string A, string B) &#123; if(A == "" || B == "") return 0; int size1 = A.length(); int size2 = B.length(); vector&lt;vector&lt;int&gt;&gt; chess(size1 + 1,vector&lt;int&gt;(size2 + 1)); for(int i = 0;i &lt;= size1 ;i++)&#123; chess[i][0] = 0; &#125; for(int j = 0;j &lt;= size2 ;j++)&#123; chess[0][j] = 0; &#125;// cout &lt;&lt; A[0] &lt;&lt; " " &lt;&lt; B[0];// return chess[size1-1][size2-1]; for(int i = 1;i &lt;= size1 ;i++)&#123; for(int j = 1;j &lt;= size2 ;j++)&#123; if(A[i - 1] == B[j - 1]) chess[i][j] = chess[i-1][j-1] + 1; else chess[i][j] = max(chess[i][j-1],chess[i-1][j]); &#125; &#125; int i = size1; int j = size2; string a; while((i != 0) &amp;&amp; (j != 0))&#123; if(A[i+1] == B[i+1])&#123; a.push_back(A[i-1]); i--; j--; &#125; else&#123; if(chess[i][j-1] &gt; chess[i-1][j]) j--; else i--; &#125; reverse(a.begin(),a.end()); &#125; return a;&#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode-150[M]-Evaluate-Reverse-Polish-Notation]]></title>
      <url>%2F2017%2F05%2F16%2FLeetCode-150-M-Evaluate-Reverse-Polish-Notation%2F</url>
      <content type="text"><![CDATA[题目描述Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Some examples: 12[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6 算法描述该题目是考察逆波兰表达式，逆波兰表达式在考研考专业课的时候就被定义为在栈这个数据的典型问题，当时没有搞很懂，这次通过这个题目对数学表达式的后缀表示法有了清晰的认识。确实逆波兰表达式作为栈来举例子是很实用的。 表达式的可以看成一个二叉树，如果按照中序遍历的顺序得到的表达式就是表达式的中缀表达式，如果按照后序遍历得到的就是表达式的后缀表达式。逆波兰表达式的思想是遍历字符串中的字符串，如果遍历到的是数字就把该字符串压栈，如果遍历到的是运算符，就弹出栈顶的两个数字然后和运算符进行运算。算后的结果再次压入栈中。最终就得到了结果。 代码实现12345678910111213141516171819202122232425class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; s; if(tokens.size() == 0)&#123; return 0; &#125; for(string token:tokens)&#123; if(token == "+" || token == "-" || token == "*" || token == "/")&#123; int right = s.top(); s.pop(); int left = s.top(); s.pop(); if(token == "+") s.push(left + right); else if(token == "-") s.push(left - right); else if(token == "*") s.push(left * right); else if(token == "/") s.push(left / right); &#125; else&#123; s.push(stoi(token)); &#125; &#125; return s.top();&#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 32.[H] Longest Valid Parentheses]]></title>
      <url>%2F2017%2F05%2F15%2FLeetCode-32-H-Longest-Valid-Parentheses%2F</url>
      <content type="text"><![CDATA[###题目描述 Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2. Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4. 算法描述这是第一道用到栈这种数据结构。这道题很巧妙的用压栈压入序号数字的手段进行压栈,并对之后的所有符号进行遍历，如果右括号左边没有左括号的情况下就把该右括号当作开始值。而如果右括号左边还有左括号的情况下就用现在的值减去栈顶值最后就得到了想要的值。 代码实现12345678910111213141516171819202122class Solution &#123;public: int longestValidParentheses(string s) &#123; int size = s.length(); stack&lt;int&gt; a; int answer = 0; int start = -1; for(int i = 0;i &lt; size ;i++)&#123; if(s[i] == '(') a.push(i); else&#123; if(a.empty())&#123; start = i; &#125; else&#123; a.pop(); if(a.empty()) answer = max(answer,i - start); else answer = max(answer,i - a.top()); &#125; &#125; &#125; return answer;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Logistic回归]]></title>
      <url>%2F2017%2F05%2F14%2FLogistic%E5%9B%9E%E5%BD%92%2F</url>
      <content type="text"><![CDATA[logistic回归模型logistic回归分布设$X$是连续的随机变量，$X$服从logistic回归是指X具有以下分布函数和密度函数:$$(1)F(x)=P(X\le x)=\frac{1}{1+e^{\frac{-(x-\mu)}{\gamma}}}$$ $$(2)f(x)=F^{‘}(x)=\frac{e^{\frac{-(x-\mu)}{\gamma}}}{\gamma(1+e^{\frac{-(x-\mu)}{\gamma}})^2}$$ Logistic回归的密度函数$f(x)$和分布函数$F(x)$的图形如下图所示，分布函数属于Logsitic回归，其图像为一条S形曲线。 二项logistic回归模型二项logisitic回归是一种分类模型，由条件概率$P(Y|X)$表示，形式为参数化的logistic分布。随着$X$取值为实数，随机变量取值为1/0，通过监督学习的方法来估计模型参数:$$(3)P(Y=1|X)=\frac{\exp(w\cdot x+b)}{1 + \exp(w\cdot x+b)}$$ $$(4)P(Y=0|X)=\frac{1}{1+\exp(w\cdot x+b)}$$ 此处$x \in R^n$为输入，$Y\in{0,1}$为输出，$w \in R^n$和$b \in R$为参数，$w$称为权值向量，$b$称为偏置，$w*x$为其两者的内积。 对于给定的输入序列$x$ 按照上面两式可以求得$P(Y=1|x)$以及$P(Y=0|x)$,然后再比较两者的大小，比较之后就可以将$x$分到概率值较大的那个类，进而完成了分类操作。 而有时为了方便会扩充权值向量和输入向量，其仍然记做$w,x$，此时权值向量和输入向量就不为一维的而是多维的，此时$w=(w^1,w^2,w^3,…,w^n,b)^T$,x=(x^1,x^2,x^3,….,x^n,1)^T,此时其回归模型如下:$$(5)P(Y=1|X)=\frac{\exp(w\cdot x)}{1+\exp(w\cdot x)}$$ $$(6)P(Y=0|X)=\frac{1}{1+\exp(w\cdot x)}$$ 一个事件的几率是指该事件发生的概率与该事件不发生的概率的比值，如果事件发生的概率为$p$那么该事件发生的几率为$\frac{p}{1-p}$,那么该事件发生的对数几率(logit函数)为： $$logit(p)=log\frac{p}{1-p}$$ 对于logistic回归来说，其对数几率为： $$\log\frac{P(Y=1|x)}{1-P(Y=1|x)}=w\cdot x$$ 在logistic回归中，输出$Y=1$的对数几率是输入$x$ 的线性函数，输出$Y=1$的对数几率是由输入$x$的线性函数构成的。线性函数的值越接近于正无穷，概率值就越接近1，越接近于负无穷，概率值就越接近0. 模型参数估计假设$$P(Y=1|x)=\pi(x),$$ $$P(Y=0|x)=1-\pi(x),$$ 那么其似然函数为:$$\prod_{i=1}^N[\pi(x_i)]^{y_i}[1-\pi(x_i)]^{1-y_i}$$其对数似然为:$$L(w)=\sum_{i=1}^N[y_ilog\pi(x_i)+(1-y_i)log(1-\pi(x_i))]$$ $$=\sum_{i=1}^N[y_ilog\frac{\pi(x_i)}{1-\pi(x_i)}+log(1-\pi(x_i))]$$ $$=\sum_{i=1}^N[y_i(w_i\cdot x_i)-log(1+exp(w\cdot x_i))]$$ 这样，问题就变成了以对数似然作为目标函数的最优化问题，logistic回归中通常采用梯度下降法和拟牛顿法。利用这些方法可以轻松的求出题目所需的$w$。 多项logistic回归上面介绍的logistic回归构成了二项分类模型，可以用于二类分类。如果将其推广为多项logistic回归，那么可以用于多类分类。假设离散型随机变量的Y的取值为{1,2,….,K}，那么该logistic回归的模型为:$$P(Y=k|x)=\frac{\exp(w_k\cdot x)}{1+\sum_{k=1}^{K-1}\exp(w_k\cdot x)}$$二项logisitic回归的方法可以用于多项logisitic回归。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 5.[M] Longest Palindromic Substring]]></title>
      <url>%2F2017%2F05%2F14%2FLeetCode-5-%5BM%5D-Longest-Palindromic-Substring%2F</url>
      <content type="text"><![CDATA[题目描述Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: 12345Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example: 123Input: &quot;cbbd&quot;Output: &quot;bb&quot; 算法描述这道这道题目比较棘手，开始想的是先得到一个字符串的反字符串，然后比较反转后的字符串和原字符串，将相同的地方搞出来。之后看到了LeetCode讨论区第一个解法，发现非常巧妙，不过那个解法是基于java的，于是用c++重写一遍。好好体会这个算法。 该算法的实现描述是找出开始结点和开始结点后的长度，然后再用substr函数截取该字符串。随即就得到了最终的结果。重点在于寻找开始结点和开始结点后的长度的值。解决这个问题所用的算法是选取中心到两边扩展的算法。然后最后从头到尾遍历整个结点，从而最终得到的也是最长的字串。用这个方法就可以求得这个题目。 代码实现1234567891011121314151617181920212223class Solution &#123;public:void checkPal(const string&amp; s,int m,int n,int&amp; pos,int&amp; len)&#123; while((m &gt;= 0) &amp;&amp; (n &lt; s.size()) &amp;&amp; s[m] == s[n])&#123; m--; n++; &#125; if( n - m - 1 &gt; len)&#123; len = n - m - 1; pos = m + 1; &#125;&#125;string longestPalindrome(string s)&#123; if (s.length() &lt;= 1) return s; int len = 0; int pos = 0; for(int i = 0;i &lt; s.length() - 1; i++)&#123; checkPal(s,i,i,pos,len); checkPal(s,i,i+1,pos,len); &#125; return s.substr(pos,len);&#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 3.[M] Longest Substring Without Repeating Characters]]></title>
      <url>%2F2017%2F05%2F13%2FLeetCode-3-%5BM%5D-Longest-Substring-Without-Repeating-Characters%2F</url>
      <content type="text"><![CDATA[题目描述Given a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 算法描述本题目的意思是找出没有重复的最长字符串并返回其最长无重复字串的最大值。 算法实现一:如下面算法实现一所示，该方法的思想是从字符串的每一个字符进行遍历，然后再截取每个字符到前一未出现字符的字符串，在看这个字符是否在该字符串内。若在字符串内，则更新拦截字符串的头部位置。若不在字符串内，则使得最大字符串长度加一。 算法实现二:这道题是求取最长连续子字符串，可以用滑动窗口算法(Slide Window)求解。 设下标为l和r,把左开右闭区间[l,r)想象成一个滑动窗口。 当 s[r] 和窗口内字符重复时， 则 l 向右滑动，缩小窗口。 当s[r] 和窗口内字符不重复时，则 r 向右滑动，扩大窗口，此时窗口内的字符串一个无重复子字符串。 代码实现算法实现一:1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int lengthOfLongestSubstring(string s);int main()&#123; int a; a = lengthOfLongestSubstring("nfpdmpi"); cout &lt;&lt; a; return 0;&#125;int lengthOfLongestSubstring(string s) &#123; char cur; int max = 1; int count = 1; int index_start,index_repeat; string cur_string; if(s.length() == 0)&#123; return 0; &#125; index_start = 0; for(int i = 1;i &lt; s.length();i++)&#123; cur = s[i]; cur_string = s.substr(index_start,count); index_repeat = cur_string.find_last_of(cur); if(index_repeat == -1)&#123; count++; if(count &gt; max)&#123; max = count; &#125; &#125; else&#123; count = count - index_repeat; index_start = index_start + index_repeat + 1; &#125; &#125; return max;&#125; 算法实现二1234567891011121314151617181920int lengthOfLongestSubstring(string s) &#123; int l = 0; int r = 0; unordered_set&lt;int&gt; setv; setv.insert(s[l]); int longest = 1; while (r &lt; s.length())&#123; if(setv.count(s[r]) != 0)&#123; setv.erase(s[l]); l++; &#125; else&#123; setv.insert(s[r]); r++; longest = max(longest,((int)setv.size())) &#125; &#125; return longest;&#125; 补充substr方法substr的用处为截取字符串，当为1个参数m时，返回该字符串m位后的所有元素。 若为两个参数m，n，则返回m后n位元素。 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string s = "ABCDEFGHIJKLMNOP"; string sstr1; string sstr2; sstr1 = s.substr(2,6); //CDEFGH sstr2 = s.substr(2); //CDEFGHIJKLMNOP cout &lt;&lt; "sstr1 " &lt;&lt; sstr1 &lt;&lt; '\n' &lt;&lt; "sstr2 " &lt;&lt; sstr2 &lt;&lt;endl; return 0;&#125; find_last_of方法该代码也用到了find_last_of方法。该方法是在字符串中搜索想要字符的方法，并返回一个int类型，返回的值即为该字符在字符串中最后一次出现的位置，如果该字符串内无该字符，则返回-1。 同样，还有一种方法为find_first_of方法，方法使用和find_first_of方法差距不大，唯一的差距在于find_first_of方法返回该字符在字符串中第一次出现的位置，同理如果该字符串内无该字符，则返回-1。 string::nposstring::npos相当于说明查找没有匹配的值，一般string::npos和上面介绍的find方法一起使用。因此，在判断是否存在时string::npos可以相当于-1进行使用。 参考[LeetCode] 3. Longest Substring Without Repeating Characters 解题思路]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 21.[E] Merge Two Sorted Lists]]></title>
      <url>%2F2017%2F05%2F13%2FLeetCode-21-E-Merge-Two-Sorted-Lists%2F</url>
      <content type="text"><![CDATA[题目描述Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 算法描述该题输入的是两个排好序的链表，然后将它们两个链表再连成一个链表，让连好的链表的顺序也是按照从小到大的顺序来排列。具体算法是重新创建一个新的链表，然后遍历两个链表，因为输入的两个链表之前已经排好序，因此后续比较两个两个结点的大小即可。最后如果有一条链表还没有完成，那么让该链表完成空转即可完成该题目。 代码实现123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1,ListNode* l2)&#123; ListNode* head = new ListNode(0); ListNode* tmp = head; while(l1 &amp;&amp; l2)&#123; if(l1 -&gt; val &lt; l2 -&gt; val)&#123; tmp -&gt; next = l1; l1 = l1 -&gt; next; &#125;else&#123; tmp -&gt; next = l2; l2 = l2 -&gt; next; &#125; tmp = tmp -&gt; next; &#125; while(l1)&#123; tmp -&gt; next = l1; l1 = l1 -&gt; next; tmp = tmp -&gt; next; &#125; while(l2)&#123; tmp -&gt; next = l2; l2 = l2 -&gt; next; tmp = tmp -&gt; next; &#125; return head -&gt; next;&#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 160.[E] Intersection of Two Linked Lists]]></title>
      <url>%2F2017%2F05%2F12%2FLeetCode-160-E-Intersection-of-Two-Linked-Lists%2F</url>
      <content type="text"><![CDATA[题目描述Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory 算法描述本题目思路比较简单，先求出两个链表的长度，设为a_len和b_len我们这里认为长的为a_len(如果b更长，则交换a和b)然后先把长链表空转到和短链表一样的长度。然后等到他们的长度一样长了，然后分别比较其后的每一个结点。直到比较的两者相等，返回相等的结点。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(headA == NULL || headB == NULL) return NULL; ListNode *p_a = headA; ListNode *p_aa = headA; ListNode *p_b = headB; ListNode *p_bb = headB; int a_len = 0,b_len = 0; while(p_aa)&#123; a_len++; p_aa = p_aa -&gt; next; &#125; while(p_bb)&#123; b_len++; p_bb = p_bb -&gt; next; &#125; if(b_len &gt; a_len)&#123; swap(p_a,p_b); swap(a_len,b_len); &#125; for(int i = 0;i &lt; a_len - b_len ;i++)&#123; p_a = p_a -&gt; next; &#125; while(p_a)&#123; if(p_a == p_b) return p_a; else &#123; p_a = p_a -&gt; next; p_b = p_b -&gt; next; &#125; &#125; return NULL;&#125;&#125;; 补充这里补充一下求取链表长度的方法，这种方法在不少的题目里面都能用到。 12345int a_len = 0;while(p_aa)&#123; a_len++; p_aa = p_aa -&gt; next; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 86.[M] Partition List]]></title>
      <url>%2F2017%2F05%2F12%2FLeetCode-86-M-Partition-List%2F</url>
      <content type="text"><![CDATA[题目描述Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 算法描述该题目应用了快速排序的思想，在开始前建立两个链表。分别表示比给出值小和给出值大的链表。然后遍历一遍即可得到左右两个链表，之后再把右边链表链接在左边链表上，即可完成该算法。此算法的时间复杂度为o(n) 代码实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; if (head == NULL || head -&gt; next == NULL) return head; ListNode* p_lefthead = new ListNode(0); ListNode* left = p_lefthead; ListNode* p_righthead = new ListNode(0); ListNode* right = p_righthead; ListNode* ahead = head ; while(ahead)&#123; if(ahead -&gt; val &lt; x)&#123; left -&gt; next = ahead; left = ahead; &#125; else&#123; right -&gt; next = ahead; right = ahead; &#125; ahead = ahead -&gt; next; &#125; left -&gt; next = p_righthead -&gt; next; right -&gt; next = NULL; head = p_lefthead -&gt; next ; return head ;&#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[决策树]]></title>
      <url>%2F2017%2F05%2F11%2F%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
      <content type="text"><![CDATA[决策树是一种较好的分类器。决策数常用的学习算法有ID3,C4.5与CART树。决策树的特征选择准则一般是信息增益或者信息增益比。 特征选择信息增益熵是表示随机变量不确定性的量度。若X是一个取有限个值的离散随机变量，那么其概率分布为：$$P(X = x_i) = p_i,i=1,2,3….m$$则随机变量X的熵的定义为:$$H(X) = - \sum_{i=1}^n p_ilogp_i$$ 设有随机变量(X,Y),则其联合概率分布为: $$P(X=x_i,Y= y_i)=p_{i,j}, i =1,2,3….n j = 1,2,3….m$$ 随机变量X给定的条件下随机变量Y的条件熵为H(Y|X),定义为X给定条件下Y的条件概率分布的熵的X的数学期望$$H(Y|X)=\sum_{i=1}^np_iH(Y|X = x_i)$$信息增益表示得知特征X的信息而使得类Y的信息的不确定性减少的程度。 特征A对训练数据集D的信息增益g(D,A),定义为集合D的经验熵H(D)与特征A给定条件下的D的经验条件熵H(D|A)的差：$$g(D,A) = H(D) -H(D|A)$$在一般的表述中,熵(Y)与条件熵H(Y|X)的差值称为互信息，决策树学习中的信息增益等价于训练数据集中类与特征的互信息。 对于不同的特征具有不同的信息增益，因此我们一般计算信息增益准则的特征方法为：对训练数据集D计算每个特征的信息增益，并比较每个信息增益之间的大小，选择信息增益最大的特征作为我们选取的信息增益。 信息增益比信息增益的大小是相对于训练数据集的大小而言的，其并没有绝对的意义。在训练数据集的经验熵较大时，信息增益会偏大。反之，信息增益会偏小。因此定义信息增益g(D,A)和训练数据集的经验熵H(D)之比为：$$g_R(D,A)=g(D,A)/H(D)$$ 决策树的剪枝在决策树的学习中将已生成的树进行简化的过程叫做剪枝处理。即从已构建好的决策树上裁剪掉一些子树或叶子结点，并将其叶结点或根结点重新变为新叶子结点的过程。 决策树的剪枝操作往往通过极小化决策树整体的损失函数或者代价函数来实现。假设树T的叶子结点数为|T|,t为树T的叶结点，该叶结点上有$N_t$个样本点，其中k类的样本点有$N_{tk}$个，k=1,2,3,…,K。H(t)为叶结点的经验熵,$\alpha \ge 0 $为参数，则决策树学习的损失函数可以定义为:$$1.C_\alpha(T)=\sum^{|T|}_{t=1}N_tH_t(T) + \alpha|T|$$其中经验熵为:$$2.H_t(T)=-\sum_k\frac{N_{tk}}{N_t}log\frac{N_{tk}}{N_t}$$将式1的右端记为C(T)。此时可以将式1变为以下式子:$$3.C_\alpha(T)=C(T) + \alpha|T|$$其中C(T)表示模型对训练数据的预测误差，即模型与训练数据的拟合程度。|T|表示模型复杂度。参数$\alpha$控制两者之间的影响，较大的$\alpha$促使选择较简单的模型，较小的促使选择较复杂的模型，如果$\alpha$为0那么就只考虑模型与训练数据间的拟合程度，不考虑模型的复杂度。 决策树的生成只考虑了提高信息增益(信息增益比)的方法，而决策树的剪枝操作还考虑减小模型的复杂度。决策树生成学习局部的模型。决策树剪枝学习整体的模型。 几种算法的介绍ID3算法ID3算法的核心即在各个结点上应用信息增益准则进行特征选择。即遍历每个结点，对每个结点上的信息增益进行计算，选取信息增益最大的结点作为决策树的下一分支。而决策树算法只有树的生成过程，所以使用ID3算法有可能产生过拟合。 C4.5算法C4.5算法和ID3算法在使用方法上相类似，所不同的一点是在C4.5算法上使用的是信息增益率的概念。其余和ID3算法相同。 CART算法CART(classification and regression tree)模型，分类与回归树。是一个广泛应用的决策树学习方法。CART假设决策树是二叉树，内部结点的特征取值为”是”与”否”。 CART算法由两部分组成，分别是决策树的生成和决策树的剪枝。 CART算法CART生成决策树的生成过程就是递归构建二叉树的过程。对回归树用平方误差最小化准则，对分类树用基尼系数最小化准则，进行特征选取生成二叉树 回归树的生成一个回归树对应着输入空间的一个划分以及在划分单元上的输出值。假设每个输入空间划分为M个单元$R_1,R_2….R_M$并且每个$R_m$上都有一个固定的输出值$c_m$,回归树的模型可以表示为:$$(1)f(x) = \sum^M_{i=1}c_mI(x\in R_m)$$当输入划分确定的情况下，可以用平方误差(2)来表示回归树对于训练数据的预测误差，用平方误差最小的准则求解每个单元的最优输出值。$$(2)\sum_{x_i\in R_m}(y_i-f(x_i))^2$$单元$R_m$上的$c_m$的最优值是$R_m$上所有树入序列$x_i$对应的输出$y_i$的均值，即:$$(3)ave(y_i|x_i\in R_m)$$这里给出一种对输入空间进行划分的方法。选择第j个变量$x_j$和它所取得值$s$，作为切分变量和切分点，并定义两个区域：$$R_1(j,s)= {x|x^{(j)}\le s},R_2(j,s)= {x|x^{(j)}\ge s},$$然后求解下面式子:$$\min_{j,s}[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2 +\min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2]$$寻找最优切分变量j和最优切分点s。 然后遍历所有输入变量，找到最优的切分变量$j$，构成一个对$(j,s)$依次将输入空间划分为两个区域，然后再对每个区域进行着同样的事情，直到满足停止条件为止，这也就构成了一颗回归树，这样的回归树被称为最小二乘回归树。 分类树的生成分类树用基尼系数来选择最优特征，并利用基尼系数来决定最优二值切分点 在分类问题中，假设有K个类，样本点属于第k个类的概率为$p_k$则概率分布的基尼系数定义为：$$Gini(p) = \sum_{k=1}^Kp_k(1-p_k) = 1 -\sum_{k=1}^Kp_k^2$$ 对于二分类问题,其基尼系数为:$$Gini(p )= 2p(1-p)$$对于给定的样本集合D,其基尼系数为:$$Gini(D) = 1-\sum_{k=1}^K({\frac{|C_k|}{|D|}})^2$$若样本集合D根据特征A是否取某一可能值a被分割成为D1和D2，即：$$D_1={(x,y)\in D|A(x)=a},D_2 = D - D_1$$那么其基尼系数就为下面的定义:$$Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)$$基尼系数$Gini(D)$表示集合D的不确定性，基尼系数$Gini(D,A)$表示经过A=a分割后集合D的不确定性。基尼系数越大，样本集合的不确定性也就越大。 因此在构建分类树时，要选择基尼系数小的点进行特征的切分将其作为最优特征与最优切分点。根据最优切分点从现结点再生成两个子结点，循环往复。 CART剪枝CART剪枝操作分为两步，分别是从生成算法中产生决策树T的底端开始不断剪枝，直到T的跟结点，形成一个子树${T_0,T_1,T_2,…,T\ _n}$,然后第二步通过交叉验证的方法在独立的验证数据集额上对自述进行测试，从而选取最优的子树。 1.剪枝，形成子树序列。在剪枝过程中，计算子树的损失函数:$$C_\alpha(T) = C(T) +\alpha|T|$$ T是任意子树，C(T)为训练数据的预测误差，$|T|$为子树的叶结点个数，$\alpha$为参数，$C_{\alpha}(T)$为参数为$\alpha$时的子树$T$的整体损失。 给定一个固定的$\alpha$，那么一定可以得到一个使损失函数$C_{\alpha}(T)$最小的子树，将该树表示为$T_\alpha$当$\alpha$的值偏大时，最优子数$T_\alpha$就偏小。极端情况下，当$\alpha$为0时，整体树是最优的而当$\alpha$为无穷时，此仅有一个根结点是最优的。 对于剪枝的方法，用递归的方法进行剪枝，将$\alpha$从小到大0=$\alpha_0&lt;\alpha_1&lt;…&lt;\alpha_n&lt;无穷$ ，剪枝得到的子树对应着区间$\alpha \in [\alpha_i,\alpha_{i+1})$的最优子树序列${T_0,T_1,…,T_n}$,其中序列中的子树是嵌套的。 具体的，对于整体树$T_0$开始剪枝，对于$T_0$的内部结点t,以单结点的损失函数为:$$C_\alpha(t)=C(t)+\alpha$$那么以T为根结点的子树$T_t$的损失函数为:$$C_{\alpha}(T_t)=C(T_t)+\alpha|T_t|$$当$\alpha$比较小时，$T_t$的损失函数小于$t$的损失函数当$\alpha$增大到一个点时，两者相等。当$\alpha$超过那个点时，反转，此时只要$$\alpha=\frac{C(t)-C(T_t)}{|T_t|-1}$$两者就有相同的损失值，然后再对$T_t$进行剪枝。 因此在$T_0$中的每一内部结点t都计算$$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}$$它表示剪枝后整体损失函数减少的程度，在整体树$T_0$中剪掉$g(t)$最小的$T_t$，将得到的子树作为$T_1$，同时将最小的$g(t)$设置为$\alpha_1$，$T_1$为区间$[\alpha_1,\alpha_2)$的最优子树. ​ 如此剪枝下去，直至得到跟结点，在这一过程中，不断的增加$\alpha$ 的值，产生更多的新的区间。即可得到更多的剪枝后的决策树。 2.在剪枝后得到的子树序列$T_0,T_1,…..,T_2$,通过交叉验证选取最优子树$T_n$利用独立的验证数据集，测试子树序列$T_0,T_1,T_2,….T_n$中各棵子树的平方误差或者基尼系数。寻找出最优的子树，即平方误差或者基尼系数最小的树。得到最优子树后相应的$\alpha_i$也可以被确定，就得到了最优决策树$T_\alpha$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 82.[M] Remove Duplicates from Sorted List II]]></title>
      <url>%2F2017%2F05%2F11%2FLeetCode-82-M-Remove-Duplicates-from-Sorted-List-II%2F</url>
      <content type="text"><![CDATA[题目描述Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 算法描述这道题和83题不一样，这道题不仅仅要删除重复的数字，而是只要是重复的数字都要被删去。 下面用递归和非递归两种办法对该题目进行描述。(递归算法真的好奇妙！) 解法一非递归算法非递归解法除了除了next结点外,还要建立一个在现在结点前的结点last。遍历结点，如果现在结点的值和下一结点的值不相同，则前一结点的下一个值向下移动。如果现在结点的值和下一结点的不相同，则只移动现在结点和下一结点，直到遇到下次两结点值不相同的时候，再移动last结点。最后既可完成。 解法二递归算法果第一个结点和第二个结点不一样，则第一个结点可以直接作为新链表的头结点，后面继续删除重复的过程；如果第一个结点和第二个结点相同，则需要继续遍历，直到找到第一个与第一个结点不同的结点作为新链表的头结点，如果找不到，说明链表所有结点元素都一样，新链表为NULL，否则从新的头结点出发，继续删除重复的过程。 代码实现解法一非递归算法12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *deleteDuplicates(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode *p_head = new ListNode(0); p_head-&gt;next = head; ListNode *p_last; p_last = p_head; ListNode *p_current; ListNode *p_next; p_current = p_last-&gt;next; p_next = p_current-&gt;next; while (p_next) &#123; if (p_next-&gt;val != p_current-&gt;val) &#123; if (p_last-&gt;next == p_current) p_last = p_current; else p_last-&gt;next = p_current-&gt;next; &#125; p_current = p_current-&gt;next; p_next = p_next-&gt;next; &#125; if (p_last-&gt;next != p_current) p_last-&gt;next = p_current-&gt;next; return p_head -&gt; next;&#125;&#125;; 解法二递归算法12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *deleteDuplicates(ListNode* head)&#123; if(head == NULL || head -&gt; next == NULL)&#123; return head; &#125; ListNode* p = head -&gt; next; if (p -&gt; val != head -&gt; val)&#123; head -&gt; next = deleteDuplicates(p); return head; &#125; else &#123; while (p &amp;&amp; p-&gt;val == head-&gt;val) p = p-&gt;next; return deleteDuplicates(p); &#125;&#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 83.[E] Remove Duplicates from Sorted List]]></title>
      <url>%2F2017%2F05%2F10%2FLeetCode-83-E-Remove-Duplicates-from-Sorted-List%2F</url>
      <content type="text"><![CDATA[题目描述Given a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 算法描述该题目的目的是去除掉重复元素，这里对给出的链表进行遍历，如果现在的链表所指向的值和链表下一位所指向的值相同，那么就讲现在的链表指向下一个值的下一个，依此类推，最后可以得出所要求的答案。 代码实现12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head)&#123; if(head == NULL) return head; ListNode* p_current; ListNode* p_next; p_current = head; p_next = head -&gt; next; while(p_current &amp;&amp; p_next)&#123; if(p_current -&gt; val == p_next -&gt; val) &#123; p_current-&gt;next = p_next-&gt;next; &#125; else&#123; p_current = p_current -&gt; next; &#125; p_next = p_next -&gt; next; &#125; return head;&#125;&#125;; 补充充分考虑所有情况，比如在开始前就想好是不是输入为空或者0时会对最终结果会有影响。如果这里处理不好容易出现runtime error的错误。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 14.[E]Longest Common Prefix]]></title>
      <url>%2F2017%2F05%2F09%2FLeetCode-14-E-Longest-Common-Prefix%2F</url>
      <content type="text"><![CDATA[题目描述Write a function to find the longest common prefix string amongst an array of strings. 算法描述这个题是要给出一个string类型的vector，这个string的vector中有很多个string，我们要找出这些string的最长前缀。具体算法既从第一个字母开始，将他和下面的每一个字符串的该位上的字母进行比较，如果下面所有的字符串的该位上面的数字都一样，那么这个字母就是一个公共前缀。如果找到一个字母，他不是其中一个字符串中的一个，那么他就不属于公共前缀，我们在此就结束遍历，输出公共前缀即可。 代码实现123456789101112131415161718192021222324252627class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; int min = INT_MAX; if(strs.size() == 0) return ""; for(int i = 0;i &lt; strs.size() ;i++)&#123; if (strs[i].length() &lt; min) min = strs[i].length(); &#125; if (min == 0) &#123; return ""; &#125; string result; int count = 0; for (int i = 0; i &lt; min; i++) &#123; int j = 0; count = 0; for (j = 0; j &lt; strs.size(); j++) &#123; if (strs[0][i] == strs[j][i]) &#123; count++; &#125; &#125; if (count == j) result += strs[0][i]; if (count != j) break; &#125; return result;&#125;&#125;; 补充在做题时，要充分考虑输入的所有情况，对其中一些比如说输入为空或者输入为0的情况也要做充分的考虑。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 1.[E] Two Sum]]></title>
      <url>%2F2017%2F05%2F08%2FLeetCode-1-%5BE%5D-Two-Sum%2F</url>
      <content type="text"><![CDATA[题目描述Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 算法描述这道题输入一个vector\形式的数组并且输入一个目标，然后输出vector中两者相加的值等于这个目标，然后输出vector的脚标。本文先找到数组的第一个元素，然后利用目标减去第一个元素的值得到一个要查找的值，如果查找的值在该vector\中，则输出两个值的脚标，从而用这种方法来完成任务。 代码实现12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums,int target)&#123; map&lt;int,int&gt; int_map; vector&lt;int&gt; result; for(int i = 0; i &lt; nums.size() ;i++)&#123; int_map(nums[i]) = i; &#125; for(int i = 0; i &lt; nums.size() ;i++)&#123; int search = target - nums[i]; if(int_map.find(search) != int_map.end() &amp;&amp; int_map.at(search) != i)&#123; result.push_back(i); result.push_back(int_map(search)); break; &#125; &#125; return result;&#125;&#125;; 补充vector是一个很常用的容器，下面列出vector中的基本操作 12345678910111213141516171819202122(1)头文件#include&lt;vector&gt;.(2)创建vector对象，vector&lt;int&gt; vec;(3)尾部插入数字：vec.push_back(a);(4)使用下标访问元素，cout&lt;&lt;vec[0]&lt;&lt;endl;记住下标是从0开始的。(5)使用迭代器访问元素.vector&lt;int&gt;::iterator it;for(it=vec.begin();it!=vec.end();it++) cout&lt;&lt;*it&lt;&lt;endl;(6)插入元素： vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a;(7)删除元素： vec.erase(vec.begin()+2);删除第3个元素vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始(8)向量大小:vec.size();(9)清空:vec.clear();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 12.[M]Integer to Roman]]></title>
      <url>%2F2017%2F05%2F08%2FLeetCode-12-M-Integer-to-Roman%2F</url>
      <content type="text"><![CDATA[题目描述Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 算法描述本题目要给出一个范围在1-3999之间的整数，然后将这个整数变为罗马数字。解这道题的突破口就在于要找准罗马数字的表示之间的关系。 由LeetCode 13可知，罗马数字的表示规则是”左减右加”,因此IV为-1+5=4，IX为-1+10=9.当时看完这个后，我就在想那么8怎么表示呢？当时我在考虑8是VIII还是IIX。最后查询后发现8的表示法为Vlll。 因此： I(1),V(5),X(10)为1－10中可能用到的三个字母； X(10),L(50),C(100)为10-100中可能用到的三个字母; C(100),D(500),M(1000)为100-1000中用到的三个字母； 只有进位前的那一位数字是往左边降位的，其余都是在右边升位的。 比如给出1-10的罗马数字： I,II,III,IV,V,VI,VII,VIII,IX,X 因此，用1，4，9，10就可以表示罗马数字。 代码实现1234567891011121314class Solution &#123;public: string intToRoman(int num)&#123; int n[] = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; string r[] = &#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; string s = ""; for(int i = 0;num &gt; 0;num = num % n[i],i++)&#123; for(int j = 0,k = num / n[i];j &lt; k;j++)&#123; s += r[i]; &#125; &#125; return s;&#125;&#125;; 补充对于for循环。for(int i = 1;i &lt; 10;i++)其中i++得到的是本次循环后的输出值，下一次循环的时候的输入值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 13. [E]Roman to Integer]]></title>
      <url>%2F2017%2F05%2F07%2FLeetCode-13-E-Roman-to-Integer%2F</url>
      <content type="text"><![CDATA[题目描述Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 算法描述本题目是要给出一个罗马数字，然后将该罗马数字变成整数的过程。由罗马数字的组成规则可以得知，阿拉伯数字｛1，5，10，50，100，500，1000｝分别对应于罗马数字的{‘I’,’V’,’X’,’L’,’C’,’D’,’M’}。 并且观察到罗马数字和阿拉伯数字转换的小规律为: IIV = 5 - 1 - 1 = (-1) + (-1) + 5 = 3 VII = 5 + 1 + 1 = 7 I在V前面并且I比V小，因此I被解释为负数。 I在V后面并且I比V小，因此I被解释为正数。 因此算法可以这样设计，一次把所有字符串扫描一遍，从第一个字符开始到最后一个字符。一次比较当前字符a和下一个字符b,如果a\b那么就解释为a+b。 代码实现1234567891011121314151617181920212223class Solution &#123;public: int romanToInt(std::string s)&#123; int sum = 0; char char_arr[] = &#123;'I','V','X','L','C','D','M'&#125;; int int_arr[] = &#123;1,5,10,50,100,500,1000&#125;; std::map&lt;char,int&gt; roman_map; int man_len = sizeof(char_arr) / sizeof(char); for(int i = 0 ; i &lt; man_len ;i++)&#123; roman_map.insert(std::pair&lt;char,int&gt;(char_arr[i],int_arr[i])); &#125; for(int i = 0; i &lt; s.length() - 1;i++)&#123; if (roman_map[s[i]] &gt;= roman_map[s[i + 1]])&#123; sum += roman_map[s[i]]; &#125; if (roman_map[s[i]] &lt; roman_map[s[i+1]])&#123; sum -= roman_map[s[i]]; &#125; &#125; sum += roman_map[s[s.length() - 1]]; return sum; &#125;&#125;; 补充STL容器之map:map是C++的STL提供的一个很常用的键值对容器。在一一对应的数据结构中map很常用。下面对map的基本操作进行说明。 1.头文件1#include &lt;map&gt; 2.定义1map&lt;string,int&gt; my_Map; 3.插入数据12345671.my_Map[&quot;a&quot;] = 1;2.my_Map.insert(map\&lt;string,int\&gt;::value_type(&quot;b&quot;,2));3.my_Map.insert(pair\&lt;string,int\&gt;)(&quot;c&quot;,3));4.my_Map.insert(make_pair\&lt;string,int\&gt;)(&quot;d&quot;,4); 4.查找数据1int i = my_Map[&quot;a&quot;]; 5.删除数据1my_Map.erase(my_Itr); 6.返回元素数目##### 6.返回元素数目1my_Map.size() 7.判断是否为空1my_Map.empty() 8.清空所有元素1my_Map.clear()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[支持向量机-非线性支持向量机]]></title>
      <url>%2F2017%2F05%2F06%2F%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[非线性支持向量机而现实生活远比理想复杂，样本空间很难是一个能被线性分割的超平面，对于很多情况来说仅仅依靠线性是不行的。而我们定义，如果不能靠线性平面分开，而可以通过一个超曲面将正负例正确分开的问题为非线性可分问题。 核技巧非线性不好求解，希望通过线性分类问题来解决该类问题。我们所采用的方法即为对原非线性问题进行一个线性变换。通过求解该线性问题即可得出原非线性问题。如下方图所示，即将一个在二维平面的非线性问题变为了一个在三维平面的线性问题，如下图所示。 因此，我们可以知道，用线性分类方法求解非线性分类方法分为两步，首先第一步是使用一个变换讲原数据映射到一个新的空间，从而将在原空间内的非线性问题转换成为一个在新空间内的线性问题。第二步即对新空间内的线性问题用线性分类学习的方法从训练数据中学习分类模型。其中核技巧就属于这种问题。 核函数 令$\phi(x)$表示将x高位映射后的向量，于是在特征空间中划分平面可以将模型可以分为:$$(1)f(x)=w^T\phi(x)+b$$其中$w$和$b$是两个模型参数有： $$(2)\min_{w,b}\frac{1}{2}||w||^2,s.t.y_i(w^T\phi(x_i)+b)\ge1$$ 其对偶问题为: $$(3)\max_\alpha\sum_{i=1}^m\alpha_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j,s.t.\sum_{i=1}^m\alpha_iy_i=0, 0\le\alpha_i\le C$$ 不难看出，非线性支持向量机和线性支持向量机的区别在于求解x的维度不同，对于线性支持向量机为$x_i$而非线性支持向量机为x高维映射后的向量为$\phi(x_i)$. 这里的困难是计算$\phi(x_i)^T\phi(x_i)$是相当困难的。所以在此引入一个函数,该函数即为核函数$$(4)\kappa(x_i,x_j)=&lt;\phi(x_i),\phi(x_j)&gt;=\phi(x_i)^T\phi(x_j)$$对(3)进行求解后可以得到:$$(5)f(x)=w^T\phi(x)+b=\sum_{i=1}^m\alpha_iy_i\phi(x_i)^T\phi(x_j)+b=\sum_{i=1}^m\alpha_iy_i\kappa(x_i,x_j)+b$$ 常用核函数核函数的选择时非线性支持向量机中的一个很重要的问题，他和核函数最终的性能有很大的关系。下面显示了几种常用的核函数: 名称 表达式 线性核 $\kappa(x_i,x_j)=x_i^Tx_j$ 多项式核 $\kappa(x_i,x_j)=(x_jx_i + 1)^q $ 高斯核 $\kappa(x_i,x_j)=\exp(-\frac{ w_i-w_j ^2}{2\sigma^2})$ 拉普拉斯核 $\kappa(x_i,x_j)=exp(-\frac{\ \ w_i-w_j\ \ }{\sigma})$ Sigmoid核 $\kappa(x_i,x_j)=tanh(\beta x_i^Tx_j+\theta)$ 非线性支持向量机将线性支持向量机扩展到非线性支持向量机，只需要将线性支持向量机中的对偶形式的内积换为核函数即可。$$f(x)= sign(\sum_{i=1}^N\alpha_i^*y_iK(x_i,x_j) + b$$上式为非线性支持向量机的分类决策函数$K(x,z)$为其正定核函数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[支持向量机-线性支持向量机]]></title>
      <url>%2F2017%2F05%2F06%2F%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[线性支持向量机基本思想线性可分支持向量机很容易对两个区别明显且没有样本相交的情况下才能实现，现实生活中这种很理想的情况并不存在。在这些情况下线性可分支持向量机就失效了；即使可以通过线性可分支持向量机对其进行很好的分类，但是他所训练出的模型也很容易产生过拟合，于是这里就要使用线性支持向量机。 上面说过，线性支持向量机和线性可分支持向量机最大的区别在于线性可分支持向量机所用的为硬间隔,线性支持向量机采用的是软间隔。软间隔的表示如下图所示： 软间隔和硬间隔最最大的区别在于对于软间隔来说，并不需要所有的样本都能划分正确。不一定满足约束条件:$$y_i(w^Txi+b)\geq 1$$而在能满足的情况下，当然需要不满足的样本尽可能的少。所以对于线性可分支持向量机来说，优化目标为：$$(17)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^ml{0/1}(y_i(w^Txi+b)-1)$$其中$C&gt; 0$为一个常数，而$l{0/1}(z)$为“0/1损失函数”,当$z&lt;0$时为1，其余时候为0。 由上面的式子可知，如果$C$的值过于大，那么他在每次犯错后所要付出的代价就会很大，而C很小时其每次所需的代价就比较小。于是我们极端来看不难得出当C为无限小为0时，他随便犯错都无所谓，这时候线性支持向量机的作用就失去了。而当$C$为无限大的时候，这时候犯一点错误就会受到很大的惩罚，这时候一点错误都不敢犯。因此当$C$为无限大时，线性支持向量机就变为了线性可分支持向量机。不难看出，线性可分支持向量机是线性支持向量机在$C$为无穷大时的一种特例。 hinge损失函数但是在实际的应用场景中，$l{0/1}(z)$损失的数学性质不好，非凸函数且非连续函数。因此$(17)$式不好求解，这时候在支持向量机中荷叶损失函数(hinge损失)：$$(18)l{hinge}(z)=\max(0,1-z);$$当把$l{0/1}(z)$损失函数变成了$l{hinge}(z)$损失函数后，则$(17)$式变为下式$(19)$在引入松弛因子后，就成了$(20)$式：$$(19)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\max(0,1-y_i(w^Tx_i))$$ $$(20.1)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\xi_i$$ $$(20.2)s.t. y_i(w^Tx_i+b)\geq 1-\xi_i;\xi_i\geq0,i=1,2,3…m.$$ 如上图所示，上图分别为hinge函数损失函数，指数损失函数和对率损失函数。这三种损失函数的发展趋势都是一样的，但是在支持向量机中中，由于只要是等于1就算支持向量，原则上在其等于1时不能有损失，而指数损失函数和对率损失函数在等于1甚至是大于1时都有损失。因此在线性支持向量机中使用最多的是hinge损失函数，在有的教材中hinge损失函数也叫做SVM损失函数。 而将hinge损失函数融入到支持向量机中，那么支持向量机就有了另外一种解释，就是最小化以下的目标函数:$$\sum^N_{i=1}[1-y_i(wi+b)]+\lambda||w||^2$$其中第一项$1-y_i(wi+b)+$就为hinge损失函数 公式求解除了线性可分支持向量机用的是硬间隔，线性支持向量机用的是软间隔外，在其余方面这两个线性支持向量机差别不大，因此对于其公式求解，也使用如同线性可分支持向量机的求解方法，即用拉格朗日乘子法。类比公式$(7)$不难得出线性支持向量机的拉格朗日函数：$$(21)L(w,b,\alpha,\xi,\mu)=\frac{1}{2}||w||^2+C\sum_{i=1}^m\xii+\sum{i=1}^m\alpha_i(1-\xi_i-y_i(w^Txi+b))-\sum{i=1}^m\mu_i\xi_i$$ 其中$\alpha_i\geq0,\mu_i\geq0$为拉格朗日乘子。 对$L(w,b,\alpha,\xi,\mu)​$中的$w​$,$b​$和$\xi​$求偏导得出下式：$$(22)w = \sum_{i=1}^m\alpha_iy_ix_i,$$ $$(23)0=\sum_{i=1}^m\alpha_iy_i,$$ $$(24)C=\alpha_i+\mu_i$$ 将$(22)(23)(24)$带入$(21)$可以得到$(20)$的对偶问题：$$(25)\max\alpha\sum{i=1}^m\alphai-\frac{1}{2}\sum{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j$$ $$(26)s.t.\sum_{i=1}^m\alpha_iy_i=0, 0\le\alpha_i\le C$$ 线性可分支持向量机和线性支持向量机两者的对偶问题进行比较可知，两者唯一的差别就是对偶函数的约束不同，对于线性可分支持向量机来说，约束条件为$0 \le \alpha_i$而线性支持向量机的约束条件为$0 \le \alpha_i \le C$。从这也可以看出，线性可分支持向量机是线性支持向量机在C区域正无穷的时候的值。 类似之前的求解，对于线性支持向量机，其KKT条件要求如下：$$(27.1)\alpha_i\ge0,\mu\ge0,$$ $$(27.2)y_if(x_i)\ge1-\xi_i$$ $$(27.3)\alpha_i(y_if(x_i)-1+\xi_i)=0$$ $$(27.4)\xi_i\ge0,u_i\xi_i=0$$ 由(27.3)得，对于任意一个训练样本均有$\alpha_i=0$或者$y_if(x_i)-1+\xi=0$如果$\alpha_i=0$则该训练样本不会对结果造成影响。如果$\alpha_i&lt; C$则$\mu_i&gt;0$那么必有$\xi_i=0$那么此时就代表该向量为支持向量，就在可分边界上。如果$\alpha_i=C$那么$\mu_i=0$,此时若$\xi_i1$则被错误分类。 这里的求解方法也和线性可分支持向量机类似，可以利用SMO对其进行求解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[支持向量机-线性可分支持向量机]]></title>
      <url>%2F2017%2F05%2F06%2F%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-%E7%BA%BF%E6%80%A7%E5%8F%AF%E5%88%86%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[介绍支持向量机是一种很好的机器学习方法，在面试中多次被用到。 支持向量机本质上是一个二分类模型，其基本问题为在训练集D在样本空间找到一个超平面，使得这个超平面起到最好的分类效果。可是何谓最好呢？在支持向量机里面最好的定义就是“最小的取最大”这里的最小即为两种分类到分界面的距离最小，而最优的份界面的选择就是要使得这里的到分界面距离最小的值取取最大的支持向量。而到中间距离最小的点即为支持向量。 支持向量机有三类，分别是线性支持向量机，线性可分支持向量机和非线性支持向量机。 线性可分支持向量机基本思想线性可分支持向量机我们重点介绍，他是线性支持向量机和非线性支持向量机的基础。在样本空间中，划分超平面的方程的表示形式如下所示： ​ $$(1)w^Tx + b = 0 $$ 其中$w^T$ = ($w_1;w_2;w_3;….;w_d$)为法向量决定了该划分超平面的距离，而b为原点距决定了超平面与原点间的距离。由此可知，划分超平面可以由法向量 $w$ 和原点距位移 $b$所确定，所确定的超平面计为$(w,b)$,则样本空间内的一点$x$到$(w,b)$的距离可以写为 ​ $$(2)r=\frac{|w^Tx + b|}{||w||}$$ 如果有一点可以被正确分类，那么不难知道如果他的x满足$ w^Tx_i + b &gt; 0 $时$ y_i = +1 $,$ w^Tx_i + b &lt; 0 $时$ y_i = -1 $ 而如果我们在这里把0的标准换位1和－1的标准，令以下成立：$$(3)w^Tx_i + b =&gt; 1 ; y_i = +1 ; w^Tx_i + b &lt;= -1 ; y_i = -1$$在使这里的大于等于和小于等于号为等号时满足的条件为支持向量。 线性可分支持向量机这里使用的是硬间隔，即在间隔中不允许存在分类点，而线性支持向量机使用的是软间隔这也是线性可分支持向量机和线性支持向量机的区别所在。 由上面知道，如果当等号成立时取支持向量。那么当他取支持向量的时候其距离为 $ y=\frac{2}{||w||}$。而我们寻找的就是使下列条件成立时的$w$和$b$的值，该数值可以使得$y$为最大。那么其约束条件为下式：$$(4)\max_{w,b}\frac{2}{||w||}$$$$(5)s.t.y_i(w^Tx_i+b) \geq 1, i =1,2,3……m.$$ 而若要求$\frac{1}{||w||}$的最大值，那么就是要求$||w||$的最小值。则就可以将上述的$(4)$式改写为以下形式：$$(6)\min_{w,b}\frac{1}{2}||w||^2\$$则5，6式即为支持向量机的基本型，其也为线性可分向量机的基本形态。 凸优化问题上式为一个凸二次规划问题，凸优化问题是指约束最优化问题$$\min_wf(w)$$ $$s.t.g_i(w)\le0,i=1,2,3….k;h_i(w)=0,i=1,2,3…l$$ 其中，目标函数$f(w)$和约束函数$g_i(w)$是$R^n$上连续的可微的凸函数，$h_i(w)$是R^n上的访射函数。当$f(w)$是二次函数且约束函数$g_i(w)$为访射函数时，上述凸优化问题就会变为凸二次规划问题。 公式求解对于以上$(5)(6)$两式，在这里可以使用拉格朗日乘子法对其进行求解，对于$(5)$式的每条约束，我们都可以添加拉格朗日乘子$\alphai \geq 0$,那么该问题的拉格朗日函数就可以写成以下式子：$$(7)L(w,b,\alpha) = \frac{1}{2}||w||^2 + \sum{i=1}^m\alpha_i(1-y_i(w^Txi+b))$$接下来用拉格朗日乘子法的套路，使用$L(w,b,\alpha)$对其进行求偏导的过程，即可消去$w$和$b$，可得他的对偶问题$(10)$：$$(8)w = \sum{i=1}^m\alpha_iy_ixi\(9)0 = \sum{j=1}^m\alpha_iyi ;\(10)max\alpha \sum_{i=1}^m\alphai - \frac{1}{2}\sum{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Txj$$对$\alpha$求解后，即可求出$w$和$b$的模型：$$(12)f(x) = w^Tx + b = \sum{i=1}^m\alpha_iy_ix_i^Tx_i＋b$$ 由以上约束可知，其满足KKT条件即：$$(13)\alpha_i \geq 0 ; y_if(x_i)-1\geq0; \alpha_i(y_if(x_i)-1)=0$$于是对于所有的点可知，要么满足$\alpha_i$=0或者$y_if(x_i)=1$对于支持向量的点即为$y_if(x_i)=1$，对于其他点就为$\alpha_i$=0。而训练所需的为支持向量点，其余点就可忽略，最终模型仅仅和支持向量有关系。 求解方法——SMO算法确定$\alpha$方法SMO方法的思想在于，除了两个变量$\alpha_i$和$\alpha_j$其余变量全部固定，然后重复下列两部获得更新后的$\alpha_i$和$\alpha_j$: 选取两个需要更新的$\alpha_i$和$\alpha_j$； 固定$\alpha_i$和$\alpha_j$外的其他参数，求解更新后的$\alpha_i$和$\alpha_j$； 只要选取的$\alpha_i$和$\alpha_j$有一个不满足KKT条件，那么目标函数就会在迭代后变得更小。一般SMO选取为两个差别很大的变量，对他们进行变化会得到更好的效果。 对于SMO的方法，由$L(w,b,\alpha)$对$b$求偏导可知$(9)$所以不难得出下式:$$(14)\alpha_iy_i+\alpha_jyj+c = 0 ; c=\sum{k=0,k!=i,j}^m\alpha_ky_k$$其中$\alpha_i$和$\alpha_j$可以相互表示，那么假设用$\alpha_i$将$\alpha_j$表示后，带入(10) 后仅有一个参数，因此就很好计算$\alpha_i$ 求解$b$的方法对于所有的支持向量都有$,y_sf(x_s)=1$即：$$(15)ys(\sum{i}\alpha_iy_ix_i^Txs+b)=1$$通过此式子就可以求出b，原则上可以使用任意一个式子来求b，但一般使用的为多个求平均值的方法来做:$$(16)b=\frac{1}{|S|}\sum{s\epsilon S}(ys-\sum{i\epsilon S}\alpha_iy_ix_i^Tx_i)$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 9. [E]Palindrome Number]]></title>
      <url>%2F2017%2F05%2F06%2FLeetCode-9-E-Palindrome-Number%2F</url>
      <content type="text"><![CDATA[题目描述Determine whether an integer is a palindrome. Do this without extra space. 方法描述此题较为简单，给出两种解法。 解法一首先第一种的解法和LeetCode 7类似，具体来看就是求出LeetCode 7的结果再和本题的输入做比较，若两者相等就输出正确，两者不等就输出错误。值得注意的一点是，所有负数都不是回文数因此在此处多加留意即可。 解法二解法二的思路是将每个数字的第一位和最后一位相继比较。如果全部相同则返回正确，有一个不同就返回错误。解法二使用一个表达位数的变量(number)老计算数字的头部。用%10取余的形式计算低位。 代码实现解法一1234567891011121314151617181920class Solution &#123;public: bool isPalindrome(int x)&#123; int y = x; if(x &lt; 0) return false; if(x == 0) return true; int reverse = 0; while(x &gt;= 1)&#123; int new_reverse = 0; new_reverse = reverse * 10 + x % 10; if(((new_reverse - x % 10) / 10) != reverse) return false; reverse = new_reverse; x = x / 10; &#125; if(reverse == y) return true; if(reverse != y) return false;&#125;&#125;; 解法二12345678910111213141516171819class Solution &#123;public: bool isPalindrome(int x)&#123; if(x &lt; 0) return false; if(x == 0) return true; int div = 1; while(x / div &gt;= 10)&#123; div *= 10; &#125; while(x != 0)&#123; int l = x / div; int n = x % 10; if (l != n) return false; x = (x % div) / 10; div /= 100; &#125; return true;&#125;&#125;; 补充解法二提供了一种很好的掐头去尾的做法，这种做法可以当作一个套路应用数字求解问题中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 7. [E]Reverse Integer]]></title>
      <url>%2F2017%2F05%2F06%2FLeetCode-7-Reverse-Integer%2F</url>
      <content type="text"><![CDATA[题目描述Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 算法描述这道题是easy题，题目本身没有什么难度。但是对于溢出检测这一点的确让人伤了不少脑筋。也许这也是这道题要考察大家的点吧。 主要的算法就是下面这句: 1result = result * 10 +x % 10 完成代码版本11234567891011121314151617class Solution &#123;public:int reverse(int x) &#123; int y = abs(x); int result = 0; while(y &gt;= 1)&#123; int newresult = result * 10 + y % 10; if(((newresult - y % 10) / 10) != result) return 0; y = y / 10; result = newresult; &#125; if(x == 0) return 0; if(x &gt; 0) return result; if(x &lt; 0) return -result;&#125;&#125;; 版本212345678910111213141516171819class Solution &#123;public:int reverse(int x) &#123; int result = 0; while(x != 0 )&#123; if(result &gt; INT_MAX / 10 || ((result == INT_MAX / 10) &amp;&amp; (result % 10 &gt; INT_MAX / 10))) &#123; result = 0; break; &#125; if(result &lt; INT_MIN / 10 || ((result == INT_MIN / 10) &amp;&amp; (result % 10 &lt; INT_MIN % 10)))&#123; result = 0; break; &#125; result = result * 10 + x % 10; x = x / 10; &#125; return result;&#125;&#125;; 补充本题目处理溢出的方法方法一直接用long类型就不会溢出，这种方法比较讨巧，不建议用。 方法二不用任何flag和INT_MAX的方法，只要比较一下最后输出得到的值和原来的值是否一样即可。若溢出了，则对于溢出后的值做反向操作后的值会和原来不一样。本题实现方法一的代码即用的此思路。 方法三方法三即为提前停止操作。即如果当前的数目已经大于INT_MAX/10了 那么再做一次操作，则结果必然溢出。因此代码实现二即用的此方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 2.[M]Add Two Numbers]]></title>
      <url>%2F2017%2F05%2F03%2FLeetCode-2-%5BM%5DAdd%20Two%20Numbers%2F</url>
      <content type="text"><![CDATA[题目描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 算法描述本题目的意思是给出两个非空的链表，对两个链表进行相加，之后返回相加的值，值得注意的是这两个非空的链表为逆序的，其第一位表示个位。正如上面例子所给，即为342 + 465 ＝ 807。 C++版本1C++ 版本1的代码即为最原始的思路，即把其分为四种情况，分别是L1和L2均不为空，L1为空L2不为空，L2为空L1不为空和进位不为。再对每种情况进行观察。最终得到的结果。 C++版本2c++版本2的代码构建了一个while循环，在循环内部先测试L1,若L1不为空则将L1的值加入，加入后再指向下一个L1的值。L2同L1,经历一次后即可得到一个数位p -&gt; var。之后再将计算进位的值，进行下一轮。 完成代码C++版本11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution&#123;public: ListNode *addTwoNumbers(ListNode *l1,ListNode *l2)&#123; if(!l1) return l2; if(!l2) return l1; ListNode *head = new ListNode(0); ListNode *ret = head; ListNode *p = head; int nCarry = 0; while(l1 &amp;&amp; l2)&#123; int a = l1 -&gt; val; int b = l2 -&gt; val; int c = a + b + nCarry; nCarry = c / 10; p -&gt; next = new ListNode(c % 10); p = p -&gt; next; l1 = l1 -&gt; next; l2 = l2 -&gt; next; &#125; while(l1)&#123; int a = l1 -&gt; val; int b = 0; int c = a + b + nCarry; nCarry = c / 10; p -&gt; next = new ListNode(c % 10); p = p -&gt; next; l1 = l1 -&gt; next; &#125; while(l2)&#123; int a = 0; int b = l2 -&gt; val; int c = b + nCarry; nCarry = c / 10; p -&gt; next = new ListNode(c % 10); p = p -&gt; next; l2 = l2 -&gt; next; &#125; if(nCarry)&#123; p -&gt; next = new ListNode(1); nCarry = 0; &#125; ret = ret -&gt; next; delete head; return ret; &#125;&#125;; C++版本2123456789101112131415161718192021222324class Solution&#123;public: ListNode *addTwoNumbers(ListNode *l1,ListNode *l2)&#123; ListNode *head = new ListNode(0); ListNode *p = head; int nCarry = 0; while(1)&#123; if(l1)&#123; nCarry += l1 -&gt; val; l1 = l1 -&gt; next; &#125; if(l2)&#123; nCarry += l2 -&gt; val; l2 = l2 -&gt; next; &#125; p -&gt; val = nCarry % 10; nCarry /= 10; if(l1 != NULL || l2 != NULL || nCarry != 0)&#123; p = (p -&gt; next = new ListNode(0)); &#125;else break; &#125; return head; &#125;&#125;; Java版本12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; ListNode head = new ListNode(0); ListNode point = head; int carry = 0; while(l1 != null &amp;&amp; l2!=null)&#123; int sum = carry + l1.val + l2.val; point.next = new ListNode(sum % 10); carry = sum / 10; l1 = l1.next; l2 = l2.next; point = point.next; &#125; while(l1 != null) &#123; int sum = carry + l1.val; point.next = new ListNode(sum % 10); carry = sum /10; l1 = l1.next; point = point.next; &#125; while(l2 != null) &#123; int sum = carry + l2.val; point.next = new ListNode(sum % 10); carry = sum /10; l2 = l2.next; point = point.next; &#125; if (carry != 0) &#123; point.next = new ListNode(carry); &#125; return head.next; &#125;&#125; python版本1234567891011121314151617181920class Solution(object): def addTwoNumbers(self, l1, l2): head = ListNode(0) ptr = head carry = 0 while True: if l1 != None: carry += l1.val l1 = l1.next if l2 != None: carry += l2.val l2 = l2.next ptr.val = carry % 10 carry /= 10 if l1 != None or l2 != None or carry != 0: ptr.next = ListNode(0) ptr = ptr.next else: break return head]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux学习之软件包管理]]></title>
      <url>%2F2017%2F04%2F20%2Fhello%2F</url>
      <content type="text"><![CDATA[软件包系统linux系统主流软件包系统类， 软件包系统 发行版本 Debian类(.deb技术) Debian、Ubuntu等 Red Hat类(.rpm技术) Red Hat、CentOS等 其他 其他 软件包系统工具低级下载工具和高级下载工具的区别，对于低级下载工具来说。他并不是从库源下载来的，所以他并不会处理依赖问题，当dpkg过程中发现缺少依赖包的情况，那么就会报错。 发行版本 低级下载工具 Cool Debian类 dpkg apt-get、aptitude Red Hat类 rpm yum 软件包常用命令(以Debian类为例，因为常使用的版本为ubuntu) 功能 命令 查找软件包 apt-cache search search_string 安装软件包 apt-get install package_name 安装软件包文件中的软件包 dpkg —install package_file 删除软件包 apt-get remove package_name; 移除软件包(比删除更加彻底) apt-get purge package_name 更新软件包 apt-get update(upgrade) 列出软件包命令 dpkg —list 判断是否安装命令 dpkg —status package_name 显示安装包相关信息 apt-cache show package_name`]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用python把几个词语的某一位变为大写]]></title>
      <url>%2F2017%2F04%2F20%2F%E5%88%A9%E7%94%A8python%E6%8A%8A%E5%87%A0%E4%B8%AA%E8%AF%8D%E8%AF%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%BD%8D%E5%8F%98%E4%B8%BA%E5%A4%A7%E5%86%99%2F</url>
      <content type="text"><![CDATA[缘起晚上女票发给我一段她写的代码.该代码的作用是把字符串中的首字母从小写改为大写。结果产生了一定的问题，即它把所有和首字母一样的字母全部都变成了大写。代码乍一看没什么问题，但是仔细debug后发现了其中的问题所在 代码解释1234567891011#定义一个函数，该函数的功能为将输入多个单词的首位的字母由小写改为大写def LetterCapitalize(str): #先将输入的多个单词分成一个一个的小单词 wordlist=str.split()#再定义一个新的字符串，该字符串用于存放修改好的多个单词 newstr=''#对每个单词进行便利，并将首字母(word[0])被他的大写字母替代掉,最后再将替换好的字母连接起来返回 for word in wordlist: newword=word[0].upper()+word[1:] return " ".newwordprint LetterCapitalize(raw_input()) 这个代码看似没有问题，但是当测试时有问题，比如我们输入”helloh worldwa”则输出就会变为”HelloH WorldWa”这与预计完全不符。这个的原因是因为在下面word[0]本质上已经被赋值成为了h这里这段代码的意思等价于： 1word=word.replace(h,h.upper()) 因此这是主要问题所在。 另外这个代码还有问题即为输出的前面总是多一个空格，因为刚开始相当于是””+” “的形式。 正确代码1234567891011#正确代码如下，他将整个wordlist看成一个列表，列表中的每个单词为一个元素，并将元素分开处理。分为首部和去掉首部后的其他部分，和刚刚的改动之处为重新将1～len(word)的数据写了一遍这样就可以正确显示了。最终处理时，将首字母的第两个个空格略去，即可得到想要的结果def LetterCapitalize(str):wordlist = str.split()newword = ''for word in wordlist:newword = newword + " " + word[0].upper() + word[1:]result = " " + newwordreturn result[2:]print LetterCapitalize(raw_input())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SVM]]></title>
      <url>%2F2017%2F04%2F16%2FSVM%2F</url>
      <content type="text"><![CDATA[介绍支持向量机是一种很好的机器学习方法，在面试中多次被用到。 其基本问题为在训练集D在样本空间找到一个超平面，使得这个超平面起到最好的分类效果。可是何谓最好呢？在支持向量机里面最好的定义就是“最小的取最大”这里的最小即为两种分类到分界面的距离最小，而最优的份界面的选择就是要使得这里的到分界面距离最小的值取取最大的支持向量。而到中间距离最小的点即为支持向量。 支持向量机有三类，分别是线性支持向量机，线性可分支持向量机和非线性支持向量机。 线性可分支持向量机基本思想线性可分支持向量机我们重点介绍，他是线性支持向量机和非线性支持向量机的基础。在样本空间中，划分超平面的方程的表示形式如下所示： ​ $$(1)w^Tx + b = 0 $$ 其中$w^T$ = ($w_1;w_2;w_3;….;w_d$)为法向量决定了该划分超平面的距离，而b为原点距决定了超平面与原点间的距离。由此可知，划分超平面可以由法向量 $w$ 和原点距位移 $b$所确定，所确定的超平面计为$(w,b)$,则样本空间内的一点$x$到$(w,b)$的距离可以写为 ​ $$(2)r=\frac{|w^Tx + b|}{||w||}$$ 如果有一点可以被正确分类，那么不难知道如果他的x满足$ w^Tx_i + b &gt; 0 $时$ y_i = +1 $,$ w^Tx_i + b &lt; 0 $时$ y_i = -1 $ 而如果我们在这里把0的标准换位1和－1的标准，令以下成立：$$(3)w^Tx_i + b =&gt; 1 ; y_i = +1 ; w^Tx_i + b &lt;= -1 ; y_i = -1$$在使这里的大于等于和小于等于号为等号时满足的条件为支持向量。 线性可分支持向量机这里使用的是硬间隔，即在间隔中不允许存在分类点，而线性支持向量机使用的是软间隔这也是线性可分支持向量机和线性支持向量机的区别所在。 由上面知道，如果当等号成立时取支持向量。那么当他取支持向量的时候其距离为 $ y=\frac{2}{||w||}$。而我们寻找的就是使下列条件成立时的$w$和$b$的值，该数值可以使得$y$为最大。那么其约束条件为下式：$$(4)\max_{w,b}\frac{2}{||w||}$$$$(5)s.t.y_i(w^Tx_i+b) \geq 1, i =1,2,3……m.$$ 而若要求$\frac{1}{||w||}$的最大值，那么就是要求$||w||$的最小值。则就可以将上述的$(4)$式改写为以下形式：$$(6)\min_{w,b}\frac{1}{2}||w||^2\$$则5，6式即为支持向量机的基本型，其也为线性可分向量机的基本形态。 公式求解对于以上$(5)(6)$两式，在这里可以使用拉格朗日乘子法对其进行求解，对于$(5)$式的每条约束，我们都可以添加拉格朗日乘子$\alpha_i \geq 0$,那么该问题的拉格朗日函数就可以写成以下式子： $$(7)L(w,b,\alpha) = \frac{1}{2}||w||^2 + \sum_{i=1}^m\alpha_i(1-y_i(w^Tx_i+b))$$ 接下来用拉格朗日乘子法的套路，使用$L(w,b,\alpha)$对其进行求偏导的过程，即可消去$w$和$b$，可得他的对偶问题$(10)$：$$(8)w = \sum_{i=1}^m\alpha_iy_ix_i$$ $$(9)0 = \sum_{j=1}^m\alpha_iy_i ;$$ $$(10)max_\alpha\sum_{i=1}^m\alpha_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j；$$ 对$\alpha$求解后，即可求出$w$和$b$的模型： $$(12)f(x) = w^Tx + b = \sum_{i=1}^m\alpha_iy_ix_i^Tx_i＋b$$ 由以上约束可知，其满足KKT条件即： $$(13)\alpha_i \geq 0 ; y_if(x_i)-1\geq0; \alpha_i(y_if(x_i)-1)=0$$ 于是对于所有的点可知，要么满足$\alpha_i$=0或者$y_if(x_i)=1$对于支持向量的点即为$y_if(x_i)=1$，对于其他点就为$\alpha_i$=0。而训练所需的为支持向量点，其余点就可忽略，最终模型仅仅和支持向量有关系。 求解方法——SMO算法确定$\alpha$方法SMO方法的思想在于，除了两个变量$\alpha_i$和$\alpha_j$其余变量全部固定，然后重复下列两部获得更新后的$\alpha_i$和$\alpha_j$: 选取两个需要更新的$\alpha_i$和$\alpha_j$； 固定$\alpha_i$和$\alpha_j$外的其他参数，求解更新后的$\alpha_i$和$\alpha_j$； 只要选取的$\alpha_i$和$\alpha_j$有一个不满足KKT条件，那么目标函数就会在迭代后变得更小。一般SMO选取为两个差别很大的变量，对他们进行变化会得到更好的效果。 对于SMO的方法，由$L(w,b,\alpha)$对$b$求偏导可知$(9)$所以不难得出下式: $$(14)\alpha_iy_i+\alpha_jy_j+c = 0 ; c=\sum_{k=0,k!=i,j}^m\alpha_ky_k$$ 其中$\alpha_i$和$\alpha_j$可以相互表示，那么假设用$\alpha_i$将$\alpha_j$表示后，带入(10) 后仅有一个参数，因此就很好计算$\alpha_i$ 求解$b$的方法对于所有的支持向量都有$,y_sf(x_s)=1$即： $$(15)y_s(\sum_{i}\alpha_iy_ix_i^Tx_s+b)=1$$ 通过此式子就可以求出b，原则上可以使用任意一个式子来求b，但一般使用的为多个求平均值的方法来做: $$(16)b=\frac{1}{|S|}\sum_{s\epsilon S}(y_s-\sum_{i\epsilon S}\alpha_iy_ix_i^Tx_i)$$ 线性支持向量机基本思想线性可分支持向量机很容易对两个区别明显且没有样本相交的情况下才能实现，现实生活中这种很理想的情况并不存在。在这些情况下线性可分支持向量机就失效了；即使可以通过线性可分支持向量机对其进行很好的分类，但是他所训练出的模型也很容易产生过拟合，于是这里就要使用线性支持向量机。 上面说过，线性支持向量机和线性可分支持向量机最大的区别在于线性可分支持向量机所用的为硬间隔,线性支持向量机采用的是软间隔。软间隔的表示如下图所示： 软间隔和硬间隔最最大的区别在于对于软间隔来说，并不需要所有的样本都能划分正确。不一定满足约束条件: $$y_i(w^Tx_i+b)\geq 1$$ 而在能满足的情况下，当然需要不满足的样本尽可能的少。所以对于线性可分支持向量机来说，优化目标为： $$(17)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^ml_{0/1}(y_i(w^Tx_i+b)-1)$$ 其中$C&gt; 0$为一个常数，而$l_{0/1}(z)$为“0/1损失函数”,当$z&lt;0$时为1，其余时候为0。 由上面的式子可知，如果$C$的值过于大，那么他在每次犯错后所要付出的代价就会很大，而C很小时其每次所需的代价就比较小。于是我们极端来看不难得出当C为无限小为0时，他随便犯错都无所谓，这时候线性支持向量机的作用就失去了。而当$C$为无限大的时候，这时候犯一点错误就会受到很大的惩罚，这时候一点错误都不敢犯。因此当$C$为无限大时，线性支持向量机就变为了线性可分支持向量机。不难看出，线性可分支持向量机是线性支持向量机在$C$为无穷大时的一种特例。 但是在实际的应用场景中，$l{0/1}(z)$损失的数学性质不好，非凸函数且非连续函数。因此$(17)$式不好求解，这时候在支持向量机中荷叶损失函数(hinge损失)：$$(18)l{hinge}(z)=\max(0,1-z);$$当把$l{0/1}(z)$损失函数变成了$l{hinge}(z)$损失函数后，则$(17)$式变为下式$(19)$在引入松弛因子后，就成了$(20)$式：$$(19)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\max(0,1-y_i(w^Tx_i))$$ $$(20.1)\min{w,b}\frac{1}{2}||w||^2+C\sum{i=1}^m\xi_i$$ $$(20.2)s.t. y_i(w^Tx_i+b)\geq 1-\xi_i;\xi_i\geq0,i=1,2,3…m.$$ 如上图所示，上图分别为hinge函数损失函数，指数损失函数和对率损失函数。这三种损失函数的发展趋势都是一样的，但是在支持向量机中中，由于只要是等于1就算支持向量，原则上在其等于1时不能有损失，而指数损失函数和对率损失函数在等于1甚至是大于1时都有损失。因此在线性支持向量机中使用最多的是hinge损失函数，在有的教材中hinge损失函数也叫做SVM损失函数。 公式求解除了线性可分支持向量机用的是硬间隔，线性支持向量机用的是软间隔外，在其余方面这两个线性支持向量机差别不大，因此对于其公式求解，也使用如同线性可分支持向量机的求解方法，即用拉格朗日乘子法。类比公式$(7)$不难得出线性支持向量机的拉格朗日函数：$$L(w,b,\alpha,\xi,\mu)=\frac{1}{2}||w||^2+C\sum_{i=1}^m\xii+\sum{i=1}^m\alpha_i(1-\xi_i-y_i(w^Txi+b))-\sum{i=1}^m\mu_i\xi_i$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux学习之：定制shell提示符]]></title>
      <url>%2F2017%2F04%2F16%2FLinux%E5%AD%A6%E4%B9%A0%E4%B9%8B%EF%BC%9A%E5%AE%9A%E5%88%B6shell%E6%8F%90%E7%A4%BA%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[在系统初始化提示符的时候，提示符的样子如下: haoz@linux:~$ 通过以下命令可以查到PS1的值 修改命令提示行的样式1echo $PS1 再通过下图所示的shell提示符中使用的转义字符即可对shell提示符进行自己想要的修改命令: 修改命令提示行的颜色除了自定义命令行的显示类型外，还可以定义命令行的现实颜色，具体代码如下： 1PS1=&quot;\[\033[0;41m\]&lt;[\w]\u@\h$:&gt;\[\033[0m\]&quot; 此命令可以将命令行的背景换为红色 更改41m可以将其换位其他颜色。 修改命令提示行的光标位置1PS1=&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;[\w]\u@\h$:&gt;&quot; 此命令行的作用在每输入一行时，屏幕上方会出现一个红色的横条，横条中用黄色显示文本的时间。 下方命令对应光标移动转移序列的对应关系： 保存命令行要想把修改好的命令行永久的保存起来，就得把他存在某个地方，这里就是要存在.bashrc文件中。即将下列命令行添加到文件中： 12PS1=&quot;\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]&lt;[\w]\u@\h$:&gt;&quot;export PS1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux学习之：vi使用简介]]></title>
      <url>%2F2017%2F04%2F15%2FLinux%E5%AD%A6%E4%B9%A0%E4%B9%8B%EF%BC%9Avi%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[12# 进入vi界面$ vi vi命令模式点击esc即可进入vi的命令模式 在这里可以进行一系列命令对vi进行操作 比如说保存，关闭，查找等命令 :w 保存命令 L或者右箭头：右移动 H或者左箭头：左移动 J或者下箭头：下移动 K或者上箭头：上移动 数字0:至本行开头 Ctrl-F或者page down：下翻一页 Ctrl-B或者page up：上翻一页 shift+g：至文件的最后一行 number＋g：至文件的第number行 /:对文本进行搜索 {[%],[1,\$][1,5]}s/A/B/g(其中前面表示从多少行到多少行，%表示从第一到最后，[1,$]表示从1到最后,[1,5]表示从1到5行；s表示命令为替换操作，即搜索和替换；A表示要被替换成的语句；B为要替换的语句；g即为全局搜索) 使用n切换到下一个文件，使用N切换到上一个文件 使用buffers展示文件 r：读入文件 vi编辑模式1.进入插入模式 点击i即进入插入模式 点击o在上方插入 点击O在下方插入 点击x删除当前字符 点击“number”+x删除当前字符和之后number－1个字符 点击dd剪切当前行 点击yy复制当前行 点击p粘贴 点击“number”+dd删除当前行和后面的number－1行 点击J命令移动合并行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之抽象工厂模式]]></title>
      <url>%2F2017%2F01%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[抽象工厂模式抽象工厂模式概念简单工厂模式和工厂方法模式的本质是给入不同的属性，通过不同的属性调用不同的类从而得到不同的对象。而抽象工厂模式可以将一组具有同样主题的工厂封装起来，在简单工厂模式前加一层抽象的概念。即抽象工厂模式是一个父类工厂，通过该抽象工厂模式产生具体工厂。抽象工厂模式即为工厂的工厂。 抽象工厂模式有四种角色： 抽象工厂：担任这个角色的是工厂方法模式的核心，它是与应用系统商业逻辑无关的。 具体工厂：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统的商业逻辑紧密相关的。 抽象产品：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。 具体产品：这个角色用以代表具体的产品。 抽象工厂模式类图这里我们定义一个抽象工厂为”University”。通过这个抽象工厂生成两个具体工厂为”BUPT”和”BNU”。其中BUPT 中男生偏多且毕业生大都为工程师，所以从BUPT中生产的产品为”Boy”和”Engineer”。而BNU中女生偏多且很多毕业生做教师，于是从BNU这个工厂生产的产品为”Girl”和”Teacher”. 抽象工厂模式代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface University&#123; public Sex getSex(); public Job getJob();&#125;public interface Sex&#123; public String getSexName(); &#125;public interface Job&#123; public String getJobName(); &#125;public class BUPT implements University&#123; public Sex getSex()&#123; return new Boy(); &#125; public Job getJob()&#123; return new Engineer(); &#125;&#125;public class Engineer implements Job&#123; public String getJobName()&#123; return "engineer"; &#125;&#125;public class Boy implements Sex&#123; public String getSexName()&#123; return "boy"; &#125;&#125;public class Student&#123; public void graduate(University s)&#123; System.out.println("A graduate student is a "+s.getSex().getSexName()+" and he/she get a job of "+s.getJob().getJobName(); &#125; public static void main(String[] args)&#123; Student s = new Student(); University u = new BUPT(); s.graduate(u); &#125;&#125; 产品等级结构和产品族产品等级结构产品等级结构即产品的继承结构。比如一个抽象类为球类运动，其子类有足球、篮球等；则球类运动和篮球、足球就构成了一个产品等级结构。其中抽象的球类运动为父类，具体的球类运动为子类。 产品族在抽象工厂模式中，产品族是由同一个工厂产生，但位于不同产品等级结构中的一组产品。比如说上面的例子，产品Boy和产品Engineer都是BUPT这个工厂生产出来的。但是Boy这个产品是和Sex这个抽象父类构成一个产品等级结构，Engineer这个产品是和Job这个抽象父类构成一个产品等级结构。Boy和Engineer组成了一个产品族。 由产品族和产品等级结构就可以唯一的确定一个产品。 抽象工厂模式和工厂方法模式的区别介绍完了产品等级结构和产品族后，抽象工厂模式和工厂方法模式的区别就很明显了。工厂方法模式针对的是一个产品等级，而抽象工厂模式是针对多个产品等级。当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>%2F2017%2F01%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[设计模式之工厂模式工厂模式在面向对象的设计中，其是一个用于创建其他对象的对象。其根据不同的参数来创建不同的对象并实现不同的分配方案。例如创建“人”这个对象，输入男女的特征，工厂模式就为我们创建男人/女人。(上帝即视感！) 工厂模式分为三类： 简单工厂模式 工厂模式方法 抽象工厂模式 此篇先介绍简单工厂模式和工厂模式方法 工厂模式类图：这里我们就使用工厂模式来造人，我们先造一个男人，他每天的工作是吃饭睡觉打豆豆，顺便再踢踢球。而我们再造一个女人，那么她每天的工作也是吃饭睡觉打豆豆，顺便再买买买！下面就是该UML的类图： 简单工厂模式示例代码简单工厂模式代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//抽象产品——人类 有eat,sleep,beat方法abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat();&#125;//具体产品--男人 有eat,sleep,beat,soccer方法class Male extends Human&#123; public void eat()&#123; System.out.println("Man can eat."); &#125; public void sleep()&#123; System.out.println("Man can sleep."); &#125; public void beat()&#123; System.out.println("Man can beat doudou."); &#125;&#125;//具体产品--女人 有eat,sleep,beat,buy方法class Female extends Human&#123; public void eat()&#123; System.out.prinln("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125;&#125;/*简单工厂模式，当性别为male时构建男生方法当性别为female时构建女生方法*/public class HumanFactory&#123; public static Human createHuman(String gender)&#123; Human human = null; if(gender.equals("male")&#123; human = new Man(); &#125;else if(gender.equals("female"))&#123; human = new Female(); &#125; return human; &#125; &#125;/*女娲造人方法，用该方法造一个男人，再造一个女人*/public class Goddess&#123; pubic static void main(String[] args) throws IOException&#123; Human man = HumanFactory.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); Human woman = HumanFactory.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125;&#125; 工厂方法模式示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//抽象产品--人类abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat(); &#125;//具体产品--男人，他有吃饭，睡觉，打豆豆以及看足球的方法class Male extends Human&#123; public void eat()&#123; System.out.println("Male can eat."); &#125; public void sleep()&#123; System.out.println("Male can sleep."); &#125; public void beat()&#123; System.out.println("Male can beat doudou."); &#125; public void soccer()&#123; System.out.println("Male can play soccer."); &#125;&#125;//具体产品--女人，她有吃饭，睡觉，打豆豆及买买买的需求class Female extends Human&#123; public void eat()&#123; System.out.println("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125; public void buy()&#123; System.out.println("Female can buy"); &#125;&#125;//从这里开始使用工厂方法模式//定义一个抽象工厂类Humanabstract class HumanFactory&#123; public abstract Human createHuman(String gender) throws IOException&#123; return new Human(); &#125;&#125;//定义一个具体工厂类Female,来生产女人class FemaleFactory extends HumanFactory&#123; public Human createHuman(String gender) throws IOException&#123; return new Female(); &#125;&#125;//定义一个具体工厂类Male,来生产男人class MaleFactory extends HumanFactory&#123; public Male createHuman(String gender) throws IOException&#123; return new Male(); &#125;&#125;//定义一个上帝主类，开始造人public class Goddess&#123; public static void main(String[] args) throws IOException&#123; //创造男人 HumanFactory hfm = new MaleFactory(); Human man = hfm.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); //创造女人 HumanFactory hff = new FemaleFactory(); Human woman = hff.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125; 工厂模式用处工厂模式虽然思想简单，但是在java中有很多的用处。比如说在Java库中，根据输入不同的参数类型对象，getInstance()方法就会返回不同的结果。这里就使用了工厂模式的知识。 123456java.util.Calendar-getInstance()java.util.Canlendar-getInstance(TimeZone zone)java.util.Canlendar-getInstance(Locate aLocale)java.util.Canlendar-getInstance(TimeZone zone,Locate aLocale)java.text.NumberFormat-getInstance()java.text.NumberFormat-getInstance(Locate inLocate)]]></content>
    </entry>

    
  
  
</search>
