<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>%2F2017%2F01%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[设计模式之工厂模式工厂模式在面向对象的设计中，其是一个用于创建其他对象的对象。其根据不同的参数来创建不同的对象并实现不同的分配方案。例如创建“人”这个对象，输入男女的特征，工厂模式就为我们创建男人/女人。(上帝即视感！) 工厂模式分为三类： 简单工厂模式 工厂模式方法 抽象工厂模式 此篇先介绍简单工厂模式和工厂模式方法 工厂模式类图：这里我们就使用工厂模式来造人，我们先造一个男人，他每天的工作是吃饭睡觉打豆豆，顺便再踢踢球。而我们再造一个女人，那么她每天的工作也是吃饭睡觉打豆豆，顺便再买买买！下面就是该UML的类图： 简单工厂模式示例代码简单工厂模式代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//抽象产品——人类 有eat,sleep,beat方法abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat();&#125;//具体产品--男人 有eat,sleep,beat,soccer方法class Male extends Human&#123; public void eat()&#123; System.out.println("Man can eat."); &#125; public void sleep()&#123; System.out.println("Man can sleep."); &#125; public void beat()&#123; System.out.println("Man can beat doudou."); &#125;&#125;//具体产品--女人 有eat,sleep,beat,buy方法class Female extends Human&#123; public void eat()&#123; System.out.prinln("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125;&#125;/*简单工厂模式，当性别为male时构建男生方法当性别为female时构建女生方法*/public class HumanFactory&#123; public static Human createHuman(String gender)&#123; Human human = null; if(gender.equals("male")&#123; human = new Man(); &#125;else if(gender.equals("female"))&#123; human = new Female(); &#125; return human; &#125; &#125;/*女娲造人方法，用该方法造一个男人，再造一个女人*/public class Goddess&#123; pubic static void main(String[] args) throws IOException&#123; Human man = HumanFactory.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); Human woman = HumanFactory.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125;&#125; 工厂方法模式示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//抽象产品--人类abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat(); &#125;//具体产品--男人，他有吃饭，睡觉，打豆豆以及看足球的方法class Male extends Human&#123; public void eat()&#123; System.out.println("Male can eat."); &#125; public void sleep()&#123; System.out.println("Male can sleep."); &#125; public void beat()&#123; System.out.println("Male can beat doudou."); &#125; public void soccer()&#123; System.out.println("Male can play soccer."); &#125;&#125;//具体产品--女人，她有吃饭，睡觉，打豆豆及买买买的需求class Female extends Human&#123; public void eat()&#123; System.out.println("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125; public void buy()&#123; System.out.println("Female can buy"); &#125;&#125;//从这里开始使用工厂方法模式//定义一个抽象工厂类Humanabstract class HumanFactory&#123; public abstract Human createHuman(String gender) throws IOException&#123; return new Human(); &#125;&#125;//定义一个具体工厂类Female,来生产女人class FemaleFactory extends HumanFactory&#123; public Human createHuman(String gender) throws IOException&#123; return new Female(); &#125;&#125;//定义一个具体工厂类Male,来生产男人class MaleFactory extends HumanFactory&#123; public Male createHuman(String gender) throws IOException&#123; return new Male(); &#125;&#125;//定义一个上帝主类，开始造人public class Goddess&#123; public static void main(String[] args) throws IOException&#123; //创造男人 HumanFactory hfm = new MaleFactory(); Human man = hfm.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); //创造女人 HumanFactory hff = new FemaleFactory(); Human woman = hff.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125; 工厂模式用处工厂模式虽然思想简单，但是在java中有很多的用处。比如说在Java库中，根据输入不同的参数类型对象，getInstance()方法就会返回不同的结果。这里就使用了工厂模式的知识。 123456java.util.Calendar-getInstance()java.util.Canlendar-getInstance(TimeZone zone)java.util.Canlendar-getInstance(Locate aLocale)java.util.Canlendar-getInstance(TimeZone zone,Locate aLocale)java.text.NumberFormat-getInstance()java.text.NumberFormat-getInstance(Locate inLocate)]]></content>
    </entry>

    
  
  
</search>
