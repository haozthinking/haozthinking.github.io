<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[设计模式之抽象工厂模式]]></title>
      <url>%2F2017%2F01%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[抽象工厂模式抽象工厂模式概念简单工厂模式和工厂方法模式的本质是给入不同的属性，通过不同的属性调用不同的类从而得到不同的对象。而抽象工厂模式可以将一组具有同样主题的工厂封装起来，在简单工厂模式前加一层抽象的概念。即抽象工厂模式是一个父类工厂，通过该抽象工厂模式产生具体工厂。抽象工厂模式即为工厂的工厂。 抽象工厂模式有四种角色： 抽象工厂：担任这个角色的是工厂方法模式的核心，它是与应用系统商业逻辑无关的。 具体工厂：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统的商业逻辑紧密相关的。 抽象产品：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。 具体产品：这个角色用以代表具体的产品。 抽象工厂模式类图这里我们定义一个抽象工厂为”University”。通过这个抽象工厂生成两个具体工厂为”BUPT”和”BNU”。其中BUPT 中男生偏多且毕业生大都为工程师，所以从BUPT中生产的产品为”Boy”和”Engineer”。而BNU中女生偏多且很多毕业生做教师，于是从BNU这个工厂生产的产品为”Girl”和”Teacher”. 抽象工厂模式代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface University&#123; public Sex getSex(); public Job getJob();&#125;public interface Sex&#123; public String getSexName(); &#125;public interface Job&#123; public String getJobName(); &#125;public class BUPT implements University&#123; public Sex getSex()&#123; return new Boy(); &#125; public Job getJob()&#123; return new Engineer(); &#125;&#125;public class Engineer implements Job&#123; public String getJobName()&#123; return "engineer"; &#125;&#125;public class Boy implements Sex&#123; public String getSexName()&#123; return "boy"; &#125;&#125;public class Student&#123; public void graduate(University s)&#123; System.out.println("A graduate student is a "+s.getSex().getSexName()+" and he/she get a job of "+s.getJob().getJobName(); &#125; public static void main(String[] args)&#123; Student s = new Student(); University u = new BUPT(); s.graduate(u); &#125;&#125; 产品等级结构和产品族产品等级结构产品等级结构即产品的继承结构。比如一个抽象类为球类运动，其子类有足球、篮球等；则球类运动和篮球、足球就构成了一个产品等级结构。其中抽象的球类运动为父类，具体的球类运动为子类。 产品族在抽象工厂模式中，产品族是由同一个工厂产生，但位于不同产品等级结构中的一组产品。比如说上面的例子，产品Boy和产品Engineer都是BUPT这个工厂生产出来的。但是Boy这个产品是和Sex这个抽象父类构成一个产品等级结构，Engineer这个产品是和Job这个抽象父类构成一个产品等级结构。Boy和Engineer组成了一个产品族。 由产品族和产品等级结构就可以唯一的确定一个产品。 抽象工厂模式和工厂方法模式的区别介绍完了产品等级结构和产品族后，抽象工厂模式和工厂方法模式的区别就很明显了。工厂方法模式针对的是一个产品等级，而抽象工厂模式是针对多个产品等级。当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>%2F2017%2F01%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[设计模式之工厂模式工厂模式在面向对象的设计中，其是一个用于创建其他对象的对象。其根据不同的参数来创建不同的对象并实现不同的分配方案。例如创建“人”这个对象，输入男女的特征，工厂模式就为我们创建男人/女人。(上帝即视感！) 工厂模式分为三类： 简单工厂模式 工厂模式方法 抽象工厂模式 此篇先介绍简单工厂模式和工厂模式方法 工厂模式类图：这里我们就使用工厂模式来造人，我们先造一个男人，他每天的工作是吃饭睡觉打豆豆，顺便再踢踢球。而我们再造一个女人，那么她每天的工作也是吃饭睡觉打豆豆，顺便再买买买！下面就是该UML的类图： 简单工厂模式示例代码简单工厂模式代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//抽象产品——人类 有eat,sleep,beat方法abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat();&#125;//具体产品--男人 有eat,sleep,beat,soccer方法class Male extends Human&#123; public void eat()&#123; System.out.println("Man can eat."); &#125; public void sleep()&#123; System.out.println("Man can sleep."); &#125; public void beat()&#123; System.out.println("Man can beat doudou."); &#125;&#125;//具体产品--女人 有eat,sleep,beat,buy方法class Female extends Human&#123; public void eat()&#123; System.out.prinln("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125;&#125;/*简单工厂模式，当性别为male时构建男生方法当性别为female时构建女生方法*/public class HumanFactory&#123; public static Human createHuman(String gender)&#123; Human human = null; if(gender.equals("male")&#123; human = new Man(); &#125;else if(gender.equals("female"))&#123; human = new Female(); &#125; return human; &#125; &#125;/*女娲造人方法，用该方法造一个男人，再造一个女人*/public class Goddess&#123; pubic static void main(String[] args) throws IOException&#123; Human man = HumanFactory.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); Human woman = HumanFactory.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125;&#125; 工厂方法模式示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//抽象产品--人类abstract class Human&#123; public abstract void eat(); public abstract void sleep(); public abstract void beat(); &#125;//具体产品--男人，他有吃饭，睡觉，打豆豆以及看足球的方法class Male extends Human&#123; public void eat()&#123; System.out.println("Male can eat."); &#125; public void sleep()&#123; System.out.println("Male can sleep."); &#125; public void beat()&#123; System.out.println("Male can beat doudou."); &#125; public void soccer()&#123; System.out.println("Male can play soccer."); &#125;&#125;//具体产品--女人，她有吃饭，睡觉，打豆豆及买买买的需求class Female extends Human&#123; public void eat()&#123; System.out.println("Female can eat."); &#125; public void sleep()&#123; System.out.println("Female can sleep."); &#125; public void beat()&#123; System.out.println("Female can beat doudou."); &#125; public void buy()&#123; System.out.println("Female can buy"); &#125;&#125;//从这里开始使用工厂方法模式//定义一个抽象工厂类Humanabstract class HumanFactory&#123; public abstract Human createHuman(String gender) throws IOException&#123; return new Human(); &#125;&#125;//定义一个具体工厂类Female,来生产女人class FemaleFactory extends HumanFactory&#123; public Human createHuman(String gender) throws IOException&#123; return new Female(); &#125;&#125;//定义一个具体工厂类Male,来生产男人class MaleFactory extends HumanFactory&#123; public Male createHuman(String gender) throws IOException&#123; return new Male(); &#125;&#125;//定义一个上帝主类，开始造人public class Goddess&#123; public static void main(String[] args) throws IOException&#123; //创造男人 HumanFactory hfm = new MaleFactory(); Human man = hfm.createHuman("male"); man.eat(); man.sleep(); man.beat(); man.soccer(); //创造女人 HumanFactory hff = new FemaleFactory(); Human woman = hff.createHuman("female"); woman.eat(); woman.sleep(); woman.beat(); woman.buy(); &#125; 工厂模式用处工厂模式虽然思想简单，但是在java中有很多的用处。比如说在Java库中，根据输入不同的参数类型对象，getInstance()方法就会返回不同的结果。这里就使用了工厂模式的知识。 123456java.util.Calendar-getInstance()java.util.Canlendar-getInstance(TimeZone zone)java.util.Canlendar-getInstance(Locate aLocale)java.util.Canlendar-getInstance(TimeZone zone,Locate aLocale)java.text.NumberFormat-getInstance()java.text.NumberFormat-getInstance(Locate inLocate)]]></content>
    </entry>

    
  
  
</search>
